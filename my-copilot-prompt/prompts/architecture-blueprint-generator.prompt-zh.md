---
描述：“全面的项目架构蓝图生成器，可分析代码库以创建详细的架构文档。自动检测技术堆栈和架构模式，生成可视化图表，记录实现模式，并提供可扩展的蓝图以维护架构一致性和指导新的开发。
代理人：“代理人”
---

# 综合项目架构蓝图生成器

## 配置变量
${PROJECT_TYPE="Auto-detect|.NET|Java|React|Angular|Python|Node.js|Flutter|Other"} <!-- 主要技术 -->
${ARCHITECTURE_PATTERN="自动检测|清洁架构|微服务|分层|MVVM|MVC|六角形|事件驱动|无服务器|单体|其他"} <!-- 主要架构模式 -->
${DIAGRAM_TYPE="C4|UML|Flow|Component|None"} <!-- 架构图类型 -->
${DETAIL_LEVEL="High-level|Detailed|Com全面|Implementation-Ready"} <!-- 要包含的详细程度 -->
${INCLUDES_CODE_EXAMPLES=true|false} <!-- 包含示例代码来说明模式 -->
${INCLUDES_IMPLMENTATION_PATTERNS=true|false} <!-- 包含详细的实现模式 -->
${INCLUDES_DECISION_RECORDS=true|false} <!-- 包含架构决策记录 -->
${FOCUS_ON_EXTENSIBILITY=true|false} <!-- 强调扩展点和模式 -->

## 生成的提示

“创建一个全面的‘Project_Architecture_Blueprint.md’文档，彻底分析代码库中的架构模式，作为维护架构一致性的明确参考。使用以下方法：

### 1. 架构检测与分析
- ${PROJECT_TYPE == “自动检测”？ “分析项目结构，通过检查以下内容来识别正在使用的所有技术堆栈和框架：
  - 项目和配置文件
  - 包依赖项和导入语句
  - 特定于框架的模式和约定
  - 构建和部署配置" : "关注 ${PROJECT_TYPE} 特定模式和实践"}
  
- ${ARCHITECTURE_PATTERN == "自动检测" ? “通过分析确定架构模式：
  - 文件夹组织和命名空间
  - 依赖流和组件边界
  - 接口隔离和抽象模式
  - 组件之间的通信机制" : "记录 ${ARCHITECTURE_PATTERN} 架构是如何实现的"}

### 2. 架构概述
- 对整体架构方法提供清晰、简洁的解释
- 记录架构选择中明显的指导原则
- 确定架构边界及其执行方式
- 注意任何混合架构模式或标准模式的改编

### 3. 架构可视化
${DIAGRAM_TYPE！=“无”？ `在多个抽象级别创建 ${DIAGRAM_TYPE} 图表：
- 显示主要子系统的高级架构概述
- 显示关系和依赖关系的组件交互图
- 显示信息如何在系统中移动的数据流程图
- 确保图表准确反映实际实现，而不是理论模式`：“根据实际代码依赖关系描述组件关系，提供以下内容的清晰文字解释：
- 子系统组织和边界
- 依赖方向和组件交互
- 数据流和处理顺序"}

### 4. 核心架构组件
对于代码库中发现的每个架构组件：

- **目的和责任**：
  - 架构内的主要功能
  - 解决的业务领域或技术问题
  - 边界和范围限制

- **内部结构**：
  - 组件内类/模块的组织
  - 关键抽象及其实现
  - 使用的设计模式

- **交互模式**：
  - 组件如何与其他组件通信
  - 暴露和使用的接口
  - 依赖注入模式
  - 事件发布/订阅机制

- **进化模式**：
  - 如何扩展组件
  - 变化点和插件机制
  - 配置和定制方法

### 5. 架构层和依赖关系
- 映射代码库中实现的层结构
- 记录各层之间的依赖规则
- 识别支持层分离的抽象机制
- 注意任何循环依赖或层违规
- 用于保持分离的文档依赖注入模式

### 6. 数据架构
- 文档域模型结构和组织
- 映射实体关系和聚合模式
- 识别数据访问模式（存储库、数据映射器等）
- 文档数据转换和映射方法
- 注意缓存策略和实现
- 文档数据验证模式

### 7. 跨领域关注点的实施
记录横切关注点的实施模式：

- **身份验证和授权**：
  - 安全模型实施
  - 权限执行模式
  - 身份管理方法
  - 安全边界模式

- **错误处理和弹性**：
  - 异常处理模式
  - 重试和断路器实施
  - 回退和优雅的降级策略
  - 错误报告和监控方法

- **记录和监控**：
  - 仪表模式
  - 可观测性实施
  - 诊断信息流
  - 绩效监控方法

- **验证**：
  - 输入验证策略
  - 业务规则验证实施
  - 验证责任分配
  - 错误报告模式

- **配置管理**：
  - 配置源模式
  - 特定于环境的配置策略
  - 保密管理办法
  - 功能标志实现

### 8. 服务通信模式
- 记录服务边界定义
- 识别通信协议和格式
- 映射同步与异步通信模式
- 记录 API 版本控制策略
- 识别服务发现机制
- 注意服务通信中的弹性模式

### 9. 特定于技术的架构模式
${PROJECT_TYPE == “自动检测”？ “对于每个检测到的技术堆栈，记录特定的架构模式：”：`Document ${PROJECT_TYPE}-specific architectural patterns:`}

${(PROJECT_TYPE == ".NET" || PROJECT_TYPE == "自动检测") ? 
“#### .NET 架构模式（如果检测到）
- 主机和应用程序模型实现
- 中间件管道组织
- 框架服务集成模式
- ORM 和数据访问方法
- API 实现模式（控制器、最小 API 等）
- 依赖注入容器配置" : ""}

${(PROJECT_TYPE == "Java" || PROJECT_TYPE == "自动检测") ? 
“#### Java 架构模式（如果检测到）
- 应用程序容器和引导进程
- 依赖注入框架使用（Spring、CDI等）
- AOP 实现模式
- 交易边界管理
- ORM配置和使用模式
- 服务实现模式" : ""}

${(PROJECT_TYPE == "反应" || PROJECT_TYPE == "自动检测") ? 
“#### React 架构模式（如果检测到）
- 组件组成和重用策略
- 状态管理架构
- 副作用处理模式
- 路由和导航方法
- 数据获取和缓存模式
- 渲染优化策略" : ""}

${(PROJECT_TYPE == "Angular" || PROJECT_TYPE == "自动检测") ? 
“#### 角度架构模式（如果检测到）
- 模块组织策略
- 组件层次结构设计
- 服务和依赖注入模式
- 状态管理方法
- 反应式编程模式
- 路由守卫实施" : ""}

${(PROJECT_TYPE == "Python" || PROJECT_TYPE == "自动检测") ? 
“#### Python 架构模式（如果检测到）
- 模块组织方式
- 依赖管理策略
- OOP 与函数式实现模式
- 框架集成模式
- 异步编程方法" : ""}

### 10. 实现模式
${INCLUDES_IMPLMENTATION_PATTERNS ？ 
“记录关键架构组件的具体实现模式：

- **界面设计模式**：
  - 接口隔离方法
  - 抽象级别决策
  - 通用与特定界面模式
  - 默认实现模式

- **服务实现模式**：
  - 服务生命周期管理
  - 服务组合模式
  - 操作实施模板
  - 服务内的错误处理

- **存储库实现模式**：
  - 查询模式的实现
  - 交易管理
  - 并发处理
  - 批量操作模式

- **控制器/API实现模式**：
  - 请求处理模式
  - 响应格式化方法
  - 参数验证
  - API版本控制实施

- **领域模型实现**：
  - 实体实现模式
  - 值对象模式
  - 领域事件实现
  - 业务规则执行”：“提及详细的实现模式因代码库而异。”}

### 11. 测试架构
- 记录与架构一致的测试策略
- 识别测试边界模式（单元、集成、系统）
- 地图测试替身和模拟方法
- 记录测试数据策略
- 注意测试工具和框架集成

### 12. 部署架构
- 记录从配置派生的部署拓扑
- 确定特定环境的架构适应性
- 映射运行时依赖解析模式
- 跨环境的文档配置管理
- 确定容器化和编排方法
- 注意云服务集成模式

### 13. 扩展和演化模式
${FOCUS_ON_EXTENSIBILITY ？ 
“提供扩展架构的详细指导：

- **功能添加模式**：
  - 如何在保持架构完整性的同时添加新功能
  - 按类型放置新组件的位置
  - 依赖引入指南
  - 配置扩展模式

- **修改模式**：
  - 如何安全地修改现有组件
  - 保持向后兼容性的策略
  - 弃用模式
  - 迁移方法

- **集成模式**：
  - 如何集成新的外部系统
  - 适配器实现模式
  - 反腐败层模式
  - 服务外观实现”：“记录架构中的关键扩展点。”}

${INCLUDES_CODE_EXAMPLES ？ 
“### 14. 架构模式示例
提取说明关键架构模式的代表性代码示例：

- **层分离示例**：
  - 接口定义和实现分离
  - 跨层通信模式
  - 依赖注入示例

- **组件通信示例**：
  - 服务调用模式
  - 事件发布和处理
  - 消息传递实现

- **扩展点示例**：
  - 插件注册和发现
  - 扩展接口实现
  - 配置驱动的扩展模式

每个示例都包含足够的上下文，以清楚地展示模式，但要保持示例简洁并重点关注架构概念。" : ""}

${INCLUDES_DECISION_RECORDS ？ 
“### 15. 架构决策记录
记录代码库中明显的关键架构决策：

- **架构风格决策**：
  - 为什么选择现在的架构模式
  - 考虑的替代方案（基于代码演变）
  - 影响决策的限制因素

- **技术选择决策**：
  - 关键技术选择及其架构影响
  - 框架选择理由
  - 定制组件与现成组件的决策

- **实施方法决策**：
  - 具体实施模式的选择
  - 标准模式适应
  - 性能与可维护性的权衡

对于每个决定，请注意：
- 做出必要决定的背景
- 做出决定时考虑的因素
- 由此产生的后果（积极和消极）
- 引入未来的灵活性或限制" : ""}

### ${INCLUDES_DECISION_RECORDS ？ “16”：包括代码示例？ “15”：“14”}。架构治理
- 记录如何保持架构一致性
- 确定架构合规性的自动检查
- 注意代码库中明显的架构审查流程
- 记录架构文档实践

### ${INCLUDES_DECISION_RECORDS ？ “17”：包括代码示例？ “16”：“15”}。新发展蓝图
为实现新功能创建清晰的架构指南：

- **开发工作流程**：
  - 不同特征类型的起点
  - 组件创建顺序
  - 与现有架构的集成步骤
  - 按架构层的测试方法

- **实施模板**：
  - 关键架构组件的基类/接口模板
  - 新组件的标准文件组织
  - 依赖声明模式
  - 文件要求

- **常见陷阱**：
  - 要避免的架构违规
  - 常见的架构错误
  - 性能考虑
  - 测试盲点

包括有关此蓝图何时生成的信息以及随着架构的发展保持更新的建议。”

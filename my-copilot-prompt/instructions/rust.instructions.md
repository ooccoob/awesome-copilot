---
description: 'Rust programming language coding conventions and best practices'
applyTo: '**/*.rs'
---

# Rust 编码约定和最佳实践

编写 Rust 代码时遵循惯用的 Rust 实践和社区标准。 

这些说明基于 [The Rust Book](https://doc.rust-lang.org/book/)、[Rust API 指南](https://rust-lang.github.io/api-guidelines/)、[RFC 430 命名约定](https://github.com/rust-lang/rfcs/blob/master/text/0430-finalizing-naming-conventions.md) 以及 [users.rust-lang.org](https://users.rust-lang.org) 上更广泛的 Rust 社区。

## 一般说明

- 始终优先考虑可读性、安全性和可维护性。
- 使用强类型并利用 Rust 的所有权系统来保证内存安全。
- 将复杂的功能分解为更小、更易于管理的功能。
- 对于与算法相关的代码，请包括所使用方法的解释。
- 编写具有良好可维护性实践的代码，包括对为什么做出某些设计决策的评论。
- 使用 `Result<T, E>` 优雅地处理错误并提供有意义的错误消息。
- 对于外部依赖项，请在文档中提及其用法和目的。
- 使用遵循 [RFC 430](https://github.com/rust-lang/rfcs/blob/master/text/0430-finalizing-naming-conventions.md) 的一致命名约定。
- 编写符合借用检查器规则的惯用、安全且高效的 Rust 代码。
- 确保代码编译时没有警告。

## 遵循的模式

- 使用模块（`mod`）和公共接口（`pub`）来封装逻辑。
- 使用 `?`、`match` 或 `if let` 正确处理错误。
- 使用 `serde` 进行序列化，使用 `thiserror` 或 `anyhow` 进行自定义错误。
- 实现抽象服务或外部依赖项的特征。
- 使用 `async/await` 和 `tokio` 或 `async-std` 构造异步代码。
- 为了类型安全，优先使用枚举而不是标志和状态。
- 使用构建器来创建复杂的对象。
- 拆分二进制和库代码（`main.rs` 与 `lib.rs`）以实现可测试性和重用。
- 使用 `rayon` 进行数据并行和 CPU 密集型任务。
- 使用迭代器而不是基于索引的循环，因为它们通常更快、更安全。
- 当您不需要所有权时，请使用 `&str` 而不是 `String` 作为函数参数。
- 首选借用和零复制操作以避免不必要的分配。

### 所有权、借用和生命周期

- 除非需要转让所有权，否则优先选择借用 (`&T`) 而不是克隆。
- 当您需要修改借用的数据时，请使用 `&mut T` 。
- 当编译器无法推断生命周期时，显式注释它们。
- 使用 `Rc<T>` 进行单线程引用计数，使用 `Arc<T>` 进行线程安全引用计数。
- 使用 `RefCell<T>` 实现单线程上下文中的内部可变性，使用 `Mutex<T>` 或 `RwLock<T>` 实现多线程上下文中的内部可变性。

## 要避免的模式

- 除非绝对必要，否则不要使用 `unwrap()` 或 `expect()` — 最好进行正确的错误处理。
- 避免库代码中出现恐慌，而是返回 `Result` 。
- 不要依赖全局可变状态——使用依赖注入或线程安全容器。
- 避免深度嵌套的逻辑——使用函数或组合器进行重构。
- 不要忽略警告——在 CI 期间将它们视为错误。
- 除非需要且有完整记录，否则请避免使用 `unsafe`。
- 不要过度使用 `clone()`，使用借用而不是克隆，除非需要所有权转移。
- 避免过早的 `collect()` ，让迭代器保持惰性，直到您真正需要集合为止。
- 避免不必要的分配——优先选择借用和零拷贝操作。

## 代码风格和格式

- 遵循 Rust 风格指南并使用 `rustfmt` 进行自动格式化。
- 尽可能将行数控制在 100 个字符以下。
- 使用 `///` 将函数和结构文档放置在该项目之前。
- 使用 `cargo clippy` 捕获常见错误并实施最佳实践。

## 错误处理

- 对于可恢复的错误使用 `Result<T, E>`，仅对于不可恢复的错误使用 `panic!`。
- 对于错误传播，优先使用 `?` 运算符而不是 `unwrap()` 或 `expect()`。
- 使用 `thiserror` 创建自定义错误类型或实现 `std::error::Error`。
- 使用 `Option<T>` 表示可能存在或不存在的值。
- 提供有意义的错误消息和上下文。
- 错误类型应该有意义且行为良好（实现标准特征）。
- 验证函数参数并针对无效输入返回适当的错误。

## API设计指南

### 共同特征实施
在适当的情况下热切地实现共同特征：
- __代码0__、__代码1__、__代码2__、__代码3__、__代码4__、__代码5__、__代码6__、__代码7__、__代码8__、__代码9__
- 使用标准转换特征：`From`、`AsRef`、`AsMut`
- 集合应该实现 `FromIterator` 和 `Extend`
- 注意：`Send` 和 `Sync` 在安全时由编译器自动实现；除非使用 `unsafe` 代码，否则避免手动实现

### 类型安全性和可预测性
- 使用新类型提供静态区别
- 参数应该通过类型传达意义；与通用 `bool` 参数相比，更喜欢特定类型
- 适当地使用 `Option<T>` 来获取真正的可选值
- 具有明确接收者的函数应该是方法
- 只有智能指针应该实现 `Deref` 和 `DerefMut`

### 面向未来
- 使用密封特征来防止下游实现
- 结构应该有私有字段
- 函数应该验证它们的参数
- 所有公共类型必须实现 `Debug`

## 测试和文档

- 使用 `#[cfg(test)]` 模块和 `#[test]` 注释编写全面的单元测试。
- 将测试模块与它们测试的代码一起使用（`mod tests { ... }`）。
- 使用描述性文件名在 `tests/` 目录中编写集成测试。
- 为每个函数、结构体、枚举和复杂逻辑编写清晰简洁的注释。
- 确保函数具有描述性名称并包含全面的文档。
- 按照 [API 指南](https://rust-lang.github.io/api-guidelines/) 使用 rustdoc（`///` 注释）记录所有公共 API。
- 使用 `#[doc(hidden)]` 从公共文档中隐藏实现细节。
- 记录错误情况、紧急情况和安全注意事项。
- 示例应使用 `?` 运算符，而不是 `unwrap()` 或已弃用的 `try!` 宏。

## 项目组织

- 在 `Cargo.toml` 中使用语义版本控制。
- 包括全面的元数据：`description`、`license`、`repository`、`keywords`、`categories`。
- 使用功能标志来实现可选功能。
- 使用 `mod.rs` 或命名文件将代码组织到模块中。
- 保持 `main.rs` 或 `lib.rs` 最少 - 将逻辑移至模块。

## 质量检查表

在发布或审查 Rust 代码之前，请确保：

### 核心要求
- [ ] **命名**：遵循 RFC 430 命名约定
- [ ] **特征**：在适当的情况下实现 `Debug`、`Clone`、`PartialEq`
- [ ] **错误处理**：使用 `Result<T, E>` 并提供有意义的错误类型
- [ ] **文档**：所有公共项目都有 rustdoc 注释和示例
- [ ] **测试**：全面的测试覆盖范围，包括边缘情况

### 安全与质量
- [ ] **安全**：没有不必要的 `unsafe` 代码，正确的错误处理
- [ ] **性能**：高效使用迭代器，最少的分配
- [ ] **API设计**：函数可预测、灵活且类型安全
- [ ] **面向未来**：结构中的私有字段，在适当的情况下密封特征
- [ ] **工具**：代码传递 `cargo fmt`、`cargo clippy` 和 `cargo test`

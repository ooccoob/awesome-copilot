---
description: 'Guidelines for building Java base applications'
applyTo: '**/*.java'
---

# Java开发

## 一般说明

- 首先，提示用户是否要将静态分析工具（SonarQube、PMD、Checkstyle）集成到他们的项目设置中。
  - 如果是，请记录推荐的静态分析设置。 
    - 更喜欢 SonarQube/SonarCloud（IDE 中的 SonarLint + CI 中的 `sonar-scanner`）。
    - 创建 Sonar 项目密钥。
    - 将扫描仪令牌存储在 CI 机密中。
    - 提供运行扫描程序的示例 CI 作业。
    - 如果团队拒绝 Sonar，请在项目自述文件中注明这一点并继续。
  - 如果Sonar与项目绑定：
    - 使用声纳作为可操作问题的主要来源。
    - 修复指导中参考声纳规则关键。
  - 如果声纳不可用：
    - 最多执行 3 项故障排除检查：
      1. 验证项目绑定和令牌。
      2. 确保 SonarScanner 在 CI 中运行。
      3. 确认 SonarLint 已安装并配置。
    - 如果尝试 3 次后仍然失败：
      - 启用 SpotBugs、PMD 或 Checkstyle 作为 CI 后备。
      - 打开一个简短的跟踪问题，记录阻碍因素和后续步骤。
- 如果用户拒绝静态分析工具或希望在没有它们的情况下继续进行，请继续实施下面概述的最佳实践、错误模式和代码异味预防指南。
- 地址代码在开发过程中会主动闻到气味，而不是积累技术债务。
- 重构发现的问题时，重点关注可读性、可维护性和性能。
- 使用 IDE/代码编辑器报告警告和建议，以在开发早期捕获常见模式。

## 最佳实践

- **记录**：对于主要用于存储数据的类（例如，DTO、不可变数据结构），**应使用 Java 记录而不是传统类**。
- **模式匹配**：利用 `instanceof` 和 `switch` 表达式的模式匹配来简化条件逻辑和类型转换。
- **类型推断**：使用 `var` 进行局部变量声明以提高可读性，但前提是类型从表达式的右侧明确明确。
- **不可变性**：青睐不可变的对象。尽可能使类和字段 `final` 。使用 `List.of()`/`Map.of()` 中的集合来获取固定数据。使用 `Stream.toList()` 创建不可变列表。
- **Streams 和 Lambdas**：使用 Streams API 和 lambda 表达式进行集合处理。使用方法引用（例如 `stream.map(Foo::toBar)`）。
- **空处理**：避免返回或接受 `null`。使用 `Optional<T>` 表示可能不存在的值，使用 `Objects` 实用方法，例如 `equals()` 和 `requireNonNull()`。

### 命名约定

- 遵循 Google 的 Java 风格指南：
  - `UpperCamelCase` 用于类和接口名称。
  - `lowerCamelCase` 用于方法和变量名称。
  - `UPPER_SNAKE_CASE` 为常量。
  - `lowercase` 表示包名称。
- 使用名词表示类 (`UserService`)，使用动词表示方法 (`getUserById`)。
- 避免缩写和匈牙利符号。

### 常见错误模式

以下是简洁的、人类可读的规则，无论您使用哪种静态分析工具，您都可以应用这些规则。如果您运行 Sonar/SonarLint，IDE 将显示匹配的规则和位置 - 首选直接 Sonar 连接，并且应覆盖此规则集。

- 资源管理——始终关闭资源（文件、套接字、流）。尽可能使用 try-with-resources，以便自动关闭资源。
- 相等性检查——对于非基元，将对象相等性与 `.equals()` 或 `Objects.equals(...)` 进行比较，而不是与 `==` 进行比较；这避免了引用相等的错误。
- 冗余强制转换——删除不必要的强制转换；更喜欢正确的泛型类型，并让编译器尽可能推断类型。
- 可达条件——避免条件表达式总是为真或为假；它们表明存在错误或死代码，应该予以纠正。

对于使用 Sonar 或 SonarLint 的贡献者：IDE/扫描将显示特定的规则密钥（例如，用于资源泄漏的 S2095）和受影响的文件/行。使用该信息导航到确切位置，然后应用建议的补救措施。

### 常见的代码异味

这些模式是为人类而设计的；它们干净地映射到 Sonar、SpotBugs、PMD 或 Checkstyle 中的检查，但不需要这些工具有用。

- 参数计数——保持方法参数列表简短。如果一个方法需要许多参数，请考虑分组为值对象或使用构建器模式。
- 方法大小——保持方法集中且较小。提取辅助方法以提高可读性和可测试性。
- 认知复杂性——通过提取方法、使用多态性或应用策略模式来减少嵌套条件和大量分支。
- 重复的文字 - 将重复的字符串和数字提取到命名常量或枚举中，以减少错误并简化更改。
- 死代码——删除未使用的变量和赋值。它们会让读者感到困惑并可能隐藏错误。
- 幻数——用解释意图的命名常量替换数字文字（例如 MAX_RETRIES）。

如果您运行 Sonar 或 SonarLint 等静态分析器，则首选直接 Sonar 连接，并且应覆盖此规则集。声纳规则键对于自动化和抑制很有用，但在日常开发人员指南中并不需要它们。

## 构建和验证

- 添加或修改代码后，验证项目是否继续成功构建。
- 如果项目使用Maven，则运行`mvn clean install`。
- 如果项目使用 Gradle，请运行 `./gradlew build`（或 Windows 上的 `gradlew.bat build`）。
- 确保所有测试作为构建的一部分通过。

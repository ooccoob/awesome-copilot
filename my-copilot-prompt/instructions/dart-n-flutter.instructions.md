---
description: 'Instructions for writing Dart and Flutter code following the official recommendations.'
applyTo: '**/*.dart'
---

# Dart 和 Flutter

Dart 和 Flutter 团队推荐的最佳实践。这些说明取自 [Effective Dart](https://dart.dev/effective-dart) 和 [架构建议](https://docs.flutter.dev/app-architecture/recommendations)。

## 有效飞镖

在过去的几年里，我们编写了大量的 Dart 代码，并了解了很多关于什么有效、什么无效的知识。我们与您分享这一点，以便您也可以编写一致、健壮、快速的代码。有两个总体主题：

1.  **保持一致。** 当涉及到格式和大小写等问题时，关于哪个更好的争论是主观的，并且无法解决。我们所知道的是，保持“一致”在客观上是有帮助的。

    如果两段代码看起来不同，那应该是因为它们在某些有意义的方面“不同”。当一段代码脱颖而出并引起您的注意时，它应该是出于有用的原因。

2.  **简明扼要。** Dart 的设计是为了让人熟悉，因此它继承了许多与 C、Java、JavaScript 和其他语言相同的语句和表达式。但我们创建 Dart 是因为这些语言提供的功能还有很大的改进空间。我们添加了一系列功能，从字符串插值到初始化形式，以帮助您更简单、更轻松地表达您的意图。

    如果有多种表达方式，通常应该选择最简洁的一种。这并不是说您应该自己将整个程序塞入一行中。目标是“经济”的代码，而不是“密集”的代码。

### 主题

为了便于理解，我们将指南分为几个单独的主题：

*   **样式** – 这定义了布局和组织代码的规则，或者至少定义了 `dart format` 不为您处理的部分。样式主题还指定标识符的格式化方式：`camelCase`、`using_underscores` 等。

*   **文档** – 这会告诉您需要了解的有关评论内容的所有信息。文档注释和常规的、普通的代码注释。

*   **用法** – 这教您如何充分利用语言功能来实现行为。如果它出现在语句或表达式中，则此处会进行介绍。

*   **设计**——这是最软的话题，但范围也最广。它涵盖了我们在为库设计一致、可用的 API 方面所学到的知识。如果它在类型签名或声明中，则忽略它。

### 如何阅读主题

每个主题分为几个部分。各部分包含指南列表。每条指南均以以下单词之一开头：

*   **DO** 指南描述了应始终遵循的做法。几乎永远不会有正当理由偏离它们。

*   **不要** 准则恰恰相反：几乎从来都不是一个好主意。希望我们没有像其他语言那样多的语言，因为我们的历史包袱较少。

*   **首选**指南是您“应该”遵循的做法。然而，在某些情况下，采取其他措施可能是有意义的。只要确保您了解忽略该指南的全部含义即可。

*   **避免**准则是“首选”的双重含义：您不应该做但在极少数情况下可能有充分理由这样做的事情。

*   **考虑** 指南是您可能想要或可能不想遵循的做法，具体取决于环境、先例和您自己的偏好。

一些准则描述了规则“不”适用的**例外**。列出后，例外情况可能并不详尽，您可能仍需要对其他情况做出判断。

这听起来就像如果你没有正确系鞋带，警察就会敲你的门。事情并没有那么糟糕。这里的大部分指导方针都是常识，我们都是通情达理的人。一如既往，我们的目标是编写漂亮、可读且可维护的代码。

### 规则

#### 风格

##### 标识符

*   请使用 `UpperCamelCase` 命名类型。
*   使用 `UpperCamelCase` 进行名称扩展。
*   请使用 `lowercase_with_underscores` 命名包、目录和源文件。
*   请使用 `lowercase_with_underscores` 命名导入前缀。
*   请使用 `lowerCamelCase` 命名其他标识符。
*   优先使用 `lowerCamelCase` 作为常量名称。
*   请务必将长度超过两个字母的首字母缩写词和缩写词（如单词）大写。
*   首选对未使用的回调参数使用通配符。
*   不要对非私有标识符使用前导下划线。
*   不要使用前缀字母。
*   不要明确命名库。

##### 订购

*   请务必将 `dart:` 导入放在其他导入之前。
*   请务必将 `package:` 导入放在相对导入之前。
*   请在所有导入之后在单独的部分中指定导出。
*   请按字母顺序对各部分进行排序。

##### 格式化

*   请使用 `dart format` 格式化您的代码。
*   考虑更改您的代码以使其对格式化程序更加友好。
*   首选 80 个字符或更少的行。
*   请对所有流程控制语句使用花括号。

#### 文档

##### 评论

*   请像句子一样格式化注释。
*   不要在文档中使用块注释。

##### 文档评论

*   请使用 `///` 文档注释来记录成员和类型。
*   更喜欢为公共 API 编写文档注释。
*   考虑编写库级文档注释。
*   考虑为私有 API 编写文档注释。
*   请以单句摘要开始文档注释。
*   请务必将文档评论的第一句分成自己的段落。
*   避免与周围环境的冗余。
*   如果函数或方法的主要目的是副作用，则首选以第三人称动词开始注释。
*   首选以名词短语开头非布尔变量或属性注释。
*   首选以“是否”开始布尔变量或属性注释，后跟名词或动名词短语。
*   如果返回值是函数或方法的主要目的，则首选名词短语或非祈使动词短语。
*   不要为属性的 getter 和 setter 编写文档。
*   首选使用名词短语启动库或输入注释。
*   考虑在文档注释中包含代码示例。
*   请在文档注释中使用方括号来引用范围内的标识符。
*   请使用散文来解释参数、返回值和异常。
*   请务必将文档注释放在元数据注释之前。

##### 降价

*   避免过度使用 markdown。
*   避免使用 HTML 进行格式化。
*   首选代码块的反引号栅栏。

##### 写作

*   更喜欢简洁。
*   避免使用缩写词和首字母缩略词，除非它们很明显。
*   优先使用“this”而不是“the”来引用成员的实例。

#### 用途

##### 图书馆

*   请在 `part of` 指令中使用字符串。
*   不要导入另一个包的 `src` 目录中的库。
*   不允许导入路径进入或离开 `lib`。
*   首选相对导入路径。

##### 空

*   不要显式地将变量初始化为 `null`。
*   不要使用 `null` 的显式默认值。
*   不要在相等运算中使用 `true` 或 `false`。
*   如果需要检查变量是否已初始化，请避免使用 `late` 变量。
*   考虑使用可空类型的类型提升或空检查模式。

##### 弦乐

*   请使用相邻的字符串来连接字符串文字。
*   更喜欢使用插值来组成字符串和值。
*   不需要时，避免在插值中使用花括号。

##### 收藏

*   尽可能使用集合文字。
*   不要使用 `.length` 来查看集合是否为空。
*   避免将 `Iterable.forEach()` 与函数文字一起使用。
*   除非您打算更改结果的类型，否则不要使用 `List.from()` 。
*   请使用 `whereType()` 按类型过滤集合。
*   当附近的操作可以时，不要使用 `cast()` 。
*   避免使用 `cast()`。

##### 功能

*   请使用函数声明将函数绑定到名称。
*   当撕裂可以做到时，不要创建 lambda。

##### 变量

*   请在局部变量上遵循 `var` 和 `final` 的一致规则。
*   避免存储您可以计算的内容。

##### 会员

*   不必要时，不要将字段包装在 getter 和 setter 中。
*   首选使用 `final` 字段来创建只读属性。
*   考虑对简单成员使用 `=>` 。
*   不要使用 `this.` ，除非重定向到命名构造函数或避免阴影。
*   尽可能在声明时初始化字段。

##### 构造函数

*   尽可能使用初始化形式。
*   当构造函数初始值设定项列表可以时，不要使用 `late`。
*   对于空构造函数体，请使用 `;` 而不是 `{}`。
*   不要使用 `new`。
*   不要重复使用 `const` 。

##### 错误处理

*   避免没有 `on` 子句的捕获。
*   不要丢弃没有 `on` 子句的 catch 中的错误。
*   仅当程序错误时才抛出实现 `Error` 的对象。
*   不要显式捕获 `Error` 或实现它的类型。
*   请使用 `rethrow` 重新抛出捕获的异常。

##### 异步

*   优先使用 async/await 而不是使用原始 future。
*   当 `async` 没有任何作用时，不要使用它。
*   考虑使用高阶方法来转换流。
*   避免直接使用 Completer。
*   当消除类型参数可能是 `Object` 的 `FutureOr<T>` 的歧义时，请测试 `Future<T>`。

#### 设计

##### 名称

*   请始终如一地使用术语。
*   避免缩写。
*   喜欢将最具描述性的名词放在最后。
*   考虑让代码读起来像一个句子。
*   首选名词短语来表示非布尔属性或变量。
*   对于布尔属性或变量，首选非祈使动词短语。
*   考虑省略命名布尔参数的动词。
*   首选布尔属性或变量的“正”名称。
*   对于主要目的是副作用的函数或方法，首选祈使动词短语。
*   如果返回值是函数或方法的主要目的，则首选名词短语或非祈使动词短语。
*   如果您想引起人们对函数或方法执行的工作的注意，请考虑为函数或方法使用祈使动词短语。
*   避免以 `get` 开头的方法名称。
*   如果方法将对象的状态复制到新对象，则首选将方法命名为 `to...()`。
*   如果方法返回原始对象支持的不同表示形式，则首选命名方法 `as...()` 。
*   避免在函数或方法的名称中描述参数。
*   命名类型参数时请遵循现有的助记符约定。

##### 图书馆

*   更喜欢将声明设为私有。
*   考虑在同一个库中声明多个类。

##### 类和 mixins

*   当一个简单的函数就足够了时，避免定义一个成员抽象类。
*   避免定义仅包含静态成员的类。
*   避免扩展不打算创建子类的类。
*   请使用类修饰符来控制您的类是否可以扩展。
*   避免实现不打算成为接口的类。
*   请使用类修饰符来控制您的类是否可以是接口。
*   优先定义纯 `mixin` 或纯 `class` 而不是 `mixin class`。

##### 构造函数

*   如果类支持的话，请考虑将构造函数设置为 `const` 。

##### 会员

*   首选将字段和顶级变量设置为 `final`。
*   请使用 getter 来执行概念上访问属性的操作。
*   请使用 setter 来执行概念上更改属性的操作。
*   不要定义没有相应 getter 的 setter。
*   避免使用运行时类型测试来伪造重载。
*   避免没有初始值设定项的公共 `late final` 字段。
*   避免返回可为 null 的 `Future`、`Stream` 和集合类型。
*   避免仅仅为了启用流畅的界面而从方法中返回 `this` 。

##### 类型

*   DO 类型注释不带初始值设定项的变量。
*   如果类型不明显，请对字段和顶级变量进行类型注释。
*   不要冗余地键入注释初始化的局部变量。
*   请在函数声明上注释返回类型。
*   请在函数声明上注释参数类型。
*   不要在函数表达式上注释推断参数类型。
*   不要键入注释初始化形式。
*   请在未推断的泛型调用上写入类型参数。
*   不要在推断的泛型调用上写入类型参数。
*   避免编写不完整的泛型类型。
*   请使用 `dynamic` 进行注释，而不是让推理失败。
*   首选函数类型注释中的签名。
*   不要为 setter 指定返回类型。
*   不要使用旧版 typedef 语法。
*   优先选择内联函数类型而不是 typedef。
*   首选使用函数类型语法作为参数。
*   避免使用 `dynamic` 除非您想禁用静态检查。
*   请使用 `Future<void>` 作为不产生值的异步成员的返回类型。
*   避免使用 `FutureOr<T>` 作为返回类型。

##### 参数

*   避免位置布尔参数。
*   如果用户可能想省略前面的参数，请避免使用可选的位置参数。
*   避免接受特殊“无参数”值的强制参数。
*   请使用包含开始和排除结束参数来接受范围。

##### 平等

*   如果您覆盖 `==`，请覆盖 `hashCode`。
*   请让您的 `==` 运算符遵守数学相等规则。
*   避免为可变类定义自定义相等性。
*   不要使 `==` 的参数可为空。

---

## Flutter 架构建议

本页介绍了架构最佳实践、它们为何重要以及
我们是否推荐它们用于您的 Flutter 应用程序。
您应该将这些建议视为建议，
而不是坚定不移的规则，你应该
使它们适应您应用程序的独特要求。

此页面上的最佳实践具有优先权，
由此可见 Flutter 团队的推荐力度有多大。

* **强烈建议：** 如果出现以下情况，您应该始终实施此建议：
  您正在开始构建一个新的应用程序。你应该认真考虑
  重构现有应用程序以实施此实践，除非这样做会
  从根本上与您当前的方法相冲突。
* **推荐**：这种做法可能会改进您的应用程序。
* **有条件**：这种做法可以在某些情况下改进您的应用程序。

### 关注点分离

您应该将应用程序分为 UI 层和数据层。在这些层中，您应该按职责进一步将逻辑划分为类。

#### 使用明确定义的数据和 UI 层。
**强烈推荐**

关注点分离是最重要的架构原则。
数据层将应用程序数据公开给应用程序的其余部分，并包含应用程序中的大部分业务逻辑。
UI层显示应用程序数据并监听来自用户的用户事件。 UI 层包含用于 UI 逻辑和小部件的单独类。

#### 在数据层使用存储库模式。
**强烈推荐**

存储库模式是一种软件设计模式，它将数据访问逻辑与应用程序的其余部分隔离。
它在应用程序的业务逻辑和底层数据存储机制（数据库、API、文件系统等）之间创建一个抽象层。
实际上，这意味着创建存储库类和服务类。

#### 在 UI 层使用 ViewModel 和 View。 （MVVM）
**强烈推荐**

关注点分离是最重要的架构原则。
这种特殊的分离使您的代码更不容易出错，因为您的小部件仍然是“哑巴”。

#### 使用 `ChangeNotifiers` 和 `Listenables` 来处理小部件更新。
**有条件**

> 处理状态管理有很多选择，最终决定取决于个人喜好。

`ChangeNotifier` API 是 Fl​​utter SDK 的一部分，是让您的小部件观察 ViewModel 中的变化的便捷方法。

#### 不要将逻辑放入小部件中。
**强烈推荐**

逻辑应该封装在 ViewModel 的方法中。视图应该包含的唯一逻辑是：
* 简单的 if 语句，用于根据 ViewModel 中的标志或可为空字段显示和隐藏小部件
* 依赖widget来计算的动画逻辑
* 基于设备信息的布局逻辑，例如屏幕尺寸或方向。
* 简单的路由逻辑

#### 使用域层。
**有条件**

> 用于具有复杂逻辑要求的应用程序。

仅当您的应用程序的逻辑过于复杂且挤满了 ViewModel 时，才需要域层，
或者如果您发现自己在 ViewModel 中重复逻辑。
在非常大的应用程序中，用例很有用，但在大多数应用程序中它们会增加不必要的开销。

### 处理数据

小心处理数据可以使您的代码更易于理解、不易出错，并且
防止创建格式错误或意外的数据。

#### 使用单向数据流。
**强烈推荐**

数据更新应该只从数据层流向UI层。
UI 层中的交互被发送到数据层进行处理。

#### 使用 `Commands` 处理来自用户交互的事件。
**推荐**

命令可防止应用程序中出现渲染错误，并标准化 UI 层将事件发送到数据层的方式。

#### 使用不可变的数据模型。
**强烈推荐**

不可变数据对于确保任何必要的更改仅发生在适当的位置（通常是数据层或域层）至关重要。
由于不可变对象在创建后无法修改，因此您必须创建一个新实例来反映更改。
此过程可防止 UI 层中的意外更新，并支持清晰的单向数据流。

#### 使用 freezed 或built_value 生成不可变的数据模型。
**推荐**

您可以使用包来帮助在数据模型中生成有用的功能，`freezed` 或 `built_value`。
这些可以生成常见的模型方法，例如 JSON ser/des、深度相等检查和复制方法。
如果您有很多模型，这些代码生成包可能会显着增加应用程序的构建时间。

#### 创建单独的 API 模型和域模型。
**有条件**

> 在大型应用程序中使用。

使用单独的模型会增加冗长性，但会降低 ViewModel 和用例的复杂性。

### 应用程序结构

组织良好的代码既有利于应用程序本身的健康，也有利于处理代码的团队。

#### 使用依赖注入。
**强烈推荐**

依赖注入可防止您的应用程序具有全局可访问的对象，这使您的代码不易出错。
我们建议您使用 `provider` 包来处理依赖注入。

#### 使用 `go_router` 进行导航。
**推荐**

Go_router 是编写 90% Flutter 应用程序的首选方式。
go_router 无法解决一些特定的用例，
在这种情况下，您可以直接使用 `Flutter Navigator API` 或尝试在 `pub.dev` 上找到的其他包。

#### 对类、文件和目录使用标准化命名约定。
**推荐**

我们建议为它们所代表的架构组件命名类。
例如，您可能有以下课程：

* 主页视图模型
* 主屏幕
* 用户存储库
* 客户端API服务

为了清楚起见，我们不建议使用可能与 Flutter SDK 中的对象混淆的名称。
例如，您应该将共享小部件放在名为 `ui/core/` 的目录中，
而不是名为 `/widgets` 的目录。

#### 使用抽象存储库类
**强烈推荐**

存储库类是应用程序中所有数据的真实来源，
并促进与外部 API 的通信。
创建抽象存储库类允许您创建不同的实现，
它可用于不同的应用程序环境，例如“开发”和“登台”。

### 测试

良好的测试实践使您的应用程序变得灵活。
它还使得添加新逻辑和新 UI 变得简单且风险低。

#### 单独和一起测试架构组件。
**强烈推荐**

* 为每个服务、存储库和 ViewModel 类编写单元测试。这些测试应该单独测试每个方法的逻辑。
* 为视图编写小部件测试。测试路由和依赖注入尤其重要。

#### 制作假货进行测试（并编写利用假货的代码。）
**强烈推荐**

赝品并不关心任何给定方法的内部运作
因为他们关心的是输入和输出。如果您在编写应用程序代码时考虑到这一点，
您被迫编写具有明确定义的输入和输出的模块化、轻量级函数和类。

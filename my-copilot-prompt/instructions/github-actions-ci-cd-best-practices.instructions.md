---
applyTo: '.github/workflows/*.yml,.github/workflows/*.yaml'
description: 'Comprehensive guide for building robust, secure, and efficient CI/CD pipelines using GitHub Actions. Covers workflow structure, jobs, steps, environment variables, secret management, caching, matrix strategies, testing, and deployment strategies.'
---

# GitHub Actions CI/CD 最佳实践

## 您的使命

作为 GitHub Copilot，您是使用 GitHub Actions 设计和优化 CI/CD 管道的专家。您的任务是协助开发人员创建高效、安全且可靠的自动化工作流程来构建、测试和部署其应用程序。您必须优先考虑最佳实践、确保安全并提供可操作的详细指导。

## 核心概念和结构

### **1.工作流程结构 (`.github/workflows/*.yml`)**
- **原则：** 工作流程应该清晰、模块化、易于理解，促进可重用性和可维护性。
- **深入研究：**
    - **命名约定：** 对工作流程文件使用一致的描述性名称（例如 `build-and-test.yml`、`deploy-prod.yml`）。
    - **触发器 (`on`)：** 了解全部事件：`push`、`pull_request`、`workflow_dispatch`（手动）、`schedule`（cron 作业）、`repository_dispatch`（外部事件）、`workflow_call`（可重用工作流程）。
    - **并发性：** 使用 `concurrency` 来防止特定分支或组同时运行，避免竞争条件或浪费资源。
    - **权限：** 在工作流程级别定义 `permissions` 以获得安全默认值，如果需要，可以在作业级别覆盖。
- **副驾驶指南：**
    - 始终以描述性 `name` 和适当的 `on` 触发器开始。针对特定用例建议粒度触发器（例如，`on: push: branches: [main]` 与 `on: pull_request`）。
    - 建议使用 `workflow_dispatch` 进行手动触发器，允许输入参数以实现灵活性和受控部署。
    - 建议为关键工作流程或共享资源设置 `concurrency` 以防止资源争用。
    - 有关为 `GITHUB_TOKEN` 设置显式 `permissions` 以遵守最小权限原则的指南。
- **专业提示：** 对于复杂的存储库，请考虑使用可重用工作流程 (`workflow_call`) 来抽象常见的 CI/CD 模式并减少多个项目之间的重复。

### **2.职位**
- **原则：** 作业应该代表 CI/CD 管道的不同、独立的阶段（例如构建、测试、部署、lint、安全扫描）。
- **深入研究：**
    - **`runs-on`:** 选择合适的跑步者。 `ubuntu-latest` 很常见，但 `windows-latest`、`macos-latest` 或 `self-hosted` 运行器可满足特定需求。
    - **`needs`:** 明确定义依赖关系。如果作业 B `needs` 作业 A，则作业 B 将仅在作业 A 成功完成后运行。
    - **`outputs`:** 使用 `outputs` 在作业之间传递数据。这对于分离关注点至关重要（例如，构建作业输出工件路径，部署作业使用它）。
    - **`if` 条件：** 根据分支名称、提交消息、事件类型或先前的作业状态（`if: success()`、`if: failure()`、`if: always()`）广泛利用 `if` 条件进行条件执行。
    - **作业分组：** 考虑将大型工作流程分解为更小、更集中的并行或顺序运行的作业。
- **副驾驶指南：**
    - 使用明确的 `name` 和适当的 `runs-on` 定义 `jobs`（例如 `ubuntu-latest`、`windows-latest`、`self-hosted`）。
    - 使用`needs`定义作业之间的依赖关系，确保顺序执行和逻辑流程。
    - 使用 `outputs` 在作业之间高效地传递数据，促进模块化。
    - 利用 `if` 条件进行条件作业执行（例如，仅在 `main` 分支推送上部署、仅针对某些 PR 运行 E2E 测试、根据文件更改跳过作业）。
- **示例（条件部署和输出传递）：**
```yaml
jobs:
  build:
    runs-on: ubuntu-latest
    outputs:
      artifact_path: ${{ steps.package_app.outputs.path }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      - name: Setup Node.js
        uses: actions/setup-node@v3
        with:
          node-version: 18
      - name: Install dependencies and build
        run: |
          npm ci
          npm run build
      - name: Package application
        id: package_app
        run: | # Assume this creates a 'dist.zip' file
          zip -r dist.zip dist
          echo "path=dist.zip" >> "$GITHUB_OUTPUT"
      - name: Upload build artifact
        uses: actions/upload-artifact@v3
        with:
          name: my-app-build
          path: dist.zip

  deploy-staging:
    runs-on: ubuntu-latest
    needs: build
    if: github.ref == 'refs/heads/develop' || github.ref == 'refs/heads/main'
    environment: staging
    steps:
      - name: Download build artifact
        uses: actions/download-artifact@v3
        with:
          name: my-app-build
      - name: Deploy to Staging
        run: |
          unzip dist.zip
          echo "Deploying ${{ needs.build.outputs.artifact_path }} to staging..."
          # Add actual deployment commands here
```

### **3.步骤和行动**
- **原则：** 步骤应该是原子的、定义良好的，并且应该对操作进行版本控制以确保稳定性和安全性。
- **深入研究：**
    - **`uses`：** 引用市场操作（例如，`actions/checkout@v4`、`actions/setup-node@v3`）或自定义操作。始终固定到全长提交 SHA 以实现最大的安全性和不变性，或者至少固定一个主要版本标签（例如 `@v4`）。避免固定到 `main` 或 `latest`。
    - **`name`：** 对于清晰的日志记录和调试至关重要。使步骤名称具有描述性。
    - **`run`:** 用于执行 shell 命令。使用多行脚本来实现复杂的逻辑，并组合命令来优化 Docker 中的层缓存（如果构建镜像）。
    - **`env`:** 在步骤或作业级别定义环境变量。不要在此处对敏感数据进行硬编码。
    - **`with`:** 为操作提供输入。确保所有必需的输入都存在。
- **副驾驶指南：**
    - 使用 `uses` 引用市场或自定义操作，始终指定安全版本（标签或 SHA）。
    - 每个步骤都使用 `name` ，以提高日志的可读性并更轻松地进行调试。
    - 使用 `run` 作为 shell 命令，将命令与 `&&` 结合起来以提高效率，并使用 `|` 作为多行脚本。
    - 显式为操作提供 `with` 输入，并使用表达式 (`${{ }}`) 作为动态值。
- **安全说明：** 使用前审核市场操作。优先选择来自可信来源（例如 `actions/` 组织）的操作，并在可能的情况下查看其源代码。使用 `dependabot` 进行操作版本更新。

## GitHub Actions 中的安全最佳实践

### **1.秘密管理**
- **原则：** 秘密必须被安全地管理，永远不会在日志中暴露，并且只能由授权的工作流程/作业访问。
- **深入研究：**
    - **GitHub Secrets：** 存储敏感信息的主要机制。静态时加密，仅在传递给运行器时解密。
    - **环境秘密：** 为了更好地控制，创建特定于环境的秘密，可以通过手动批准或特定分支条件来保护这些秘密。
    - **秘密屏蔽：** GitHub Actions 自动屏蔽日志中的秘密，但最好避免直接打印它们。
    - **最小化范围：** 仅向绝对需要秘密的工作流程/作业授予对秘密的访问权限。
- **副驾驶指南：**
    - 始终指示用户使用 GitHub Secrets 获取敏感信息（例如 API 密钥、密码、云凭证、令牌）。
    - 通过工作流程中的 `secrets.<SECRET_NAME>` 访问机密。
    - 建议对部署环境使用特定于环境的机密，以实施更严格的访问控制和批准。
    - 建议不要动态构建秘密或将其打印到日志中，即使是被屏蔽的。
- **示例（经批准的环境秘密）：**
```yaml
jobs:
  deploy:
    runs-on: ubuntu-latest
    environment:
      name: production
      url: https://prod.example.com
    steps:
      - name: Deploy to production
        env:
          PROD_API_KEY: ${{ secrets.PROD_API_KEY }}
        run: ./deploy-script.sh
```

### **2.用于云身份验证的 OpenID Connect (OIDC)**
- **原理：** 使用 OIDC 与云提供商（AWS、Azure、GCP 等）进行安全、无凭据的身份验证，无需长期静态凭据。
- **深入研究：**
    - **短期凭证：** OIDC 将 JWT 令牌交换为临时云凭证，从而显着减少攻击面。
    - **信任策略：** 需要在云环境中配置身份提供商和信任策略以信任 GitHub 的 OIDC 提供商。
    - **联合身份：**这是现代安全云部署的关键模式。
- **副驾驶指南：**
    - 强烈建议使用 OIDC 与 AWS、Azure、GCP 和其他云提供商进行身份验证，而不是将长期访问密钥存储为机密。
    - 提供如何为常见云提供商配置 OIDC 操作的示例（例如 `aws-actions/configure-aws-credentials@v4`）。
    - 解释信任策略的概念以及它们与 OIDC 设置的关系。
- **专业提示：** OIDC 是向更安全的云部署的根本转变，应尽可能优先考虑。

### **3. `GITHUB_TOKEN`** 的最低权限
- **原则：** 仅向您的工作流程授予 `GITHUB_TOKEN` 必要的权限，以减少泄露时的影响范围。
- **深入研究：**
    - **默认权限：** 默认情况下，`GITHUB_TOKEN` 具有广泛的权限。这应该受到明确限制。
    - **细化权限：** 在工作流程或作业级别定义 `permissions`（例如 `contents: read`、`pull-requests: write`、`issues: read`）。
    - **默认只读：** 以 `contents: read` 作为默认值开始，仅在绝对必要时添加写入权限。
- **副驾驶指南：**
    - 在工作流程或作业级别配置 `permissions` 以限制访问。始终首选 `contents: read` 作为默认值。
    - 建议不要使用 `contents: write` 或 `pull-requests: write` ，除非工作流程明确需要修改存储库。
    - 提供常见工作流需求到特定 `GITHUB_TOKEN` 权限的清晰映射。
- **示例（最低权限）：**
```yaml
permissions:
  contents: read  # Default is write, explicitly set to read-only for security
  pull-requests: write # Only if workflow needs to update PRs
  checks: write      # For updating checks

jobs:
  lint:
    permissions:
      contents: read # This job only needs to read code, override workflow default
    steps:
      - uses: actions/checkout@v4
      - run: npm run lint
```

### **4.依赖性审查和软件构成分析 (SCA)**
- **原理：** 持续扫描依赖项以查找已知漏洞和许可问题。
- **深入研究：**
    - **早期检测：** 在 CI 管道中尽早集成依赖项检查，以便在部署之前发现问题。
    - **工具：** 使用 `dependency-review-action`、Snyk、Trivy、Mend（以前称为 WhiteSource）。
    - **供应链安全：**这是保护软件供应链的关键组成部分。
- **副驾驶指南：**
    - 将 `dependency-review-action` 或其他 SCA 工具集成到 CI 管道中。
    - 建议定期扫描第三方库中的漏洞并针对新发现设置警报。
    - 强调维护最新的依赖项列表和理解传递依赖项的重要性。

### **5.静态应用程序安全测试 (SAST)**
- **原理：** 在运行前识别源代码中的安全漏洞。
- **深入研究：**
    - **左移：** SAST 能够在开发生命周期的早期发现并修复漏洞，从而更具成本效益。
    - **工具：** CodeQL、SonarQube、Bandit (Python)、带安全插件的 ESLint (JS/TS)。
    - **自动执行：** 如果发现严重漏洞，则配置 SAST 以破坏构建或阻止 PR。
- **副驾驶指南：**
    - 将 SAST 工具（例如，用于 GitHub Advanced Security 的 CodeQL 或开源替代方案）集成到 CI 管道中。
    - 如果发现关键漏洞，则将安全扫描配置为阻止步骤，从而强制执行默认安全状态。
    - 建议将安全检查或静态分析添加到预提交挂钩中，以便尽早获得反馈。

### **6。秘密扫描和凭证泄露预防**
- **原理：** 防止机密被提交到存储库或在日志中暴露。
- **深入研究：**
    - **GitHub 秘密扫描：** 用于检测存储库中秘密的内置功能。
    - **预提交挂钩：** 像 `git-secrets` 这样的工具可以防止机密在本地提交。
    - **仅限环境变量：** 秘密只能传递到运行时需要它们的环境，而不能传递到构建工件中。
- **副驾驶指南：**
    - 建议启用 GitHub 内置的存储库秘密扫描。
    - 建议实施预提交挂钩来扫描常见的秘密模式。
    - 建议检查工作流程日志以发现意外的秘密泄露，即使进行了屏蔽。

### **7.不可变的基础设施和图像签名**
- **原则：** 确保容器镜像和部署的工件是防篡改和经过验证的。
- **深入研究：**
    - **可重复的构建：** 确保构建相同的代码始终会产生完全相同的图像。
    - **镜像签名：** 使用 Notary 或 Cosign 等工具对容器镜像进行加密签名，验证其来源和完整性。
    - **部署门：** 强制只有签名的映像才能部署到生产环境。
- **副驾驶指南：**
    - 提倡在 Dockerfile 和构建过程中进行可重复的构建。
    - 建议在部署阶段将图像签名集成到 CI 管道和验证中。

## 优化与性能

### **1.缓存 GitHub 操作**
- **原理：** 缓存依赖项并构建输出，以显着加快后续工作流程的运行速度。
- **深入研究：**
    - **缓存命中率：** 通过设计有效的缓存键来实现高缓存命中率。
    - **缓存键：** 使用基于文件哈希的唯一键（例如 `hashFiles('**/package-lock.json')`、`hashFiles('**/requirements.txt')`），仅在依赖项更改时使缓存无效。
    - **恢复密钥：** 使用 `restore-keys` 回退到较旧的兼容缓存。
    - **缓存范围：**了解缓存的范围仅限于存储库和分支。
- **副驾驶指南：**
    - 使用 `actions/cache@v3` 缓存常见的包管理器依赖项（Node.js `node_modules`、Python `pip` 包、Java Maven/Gradle 依赖项）和构建工件。
    - 使用 `hashFiles` 设计高效的缓存键，以确保最佳的缓存命中率。
    - 建议使用 `restore-keys` 优雅地回退到以前的缓存。
- **示例（Monorepo 的高级缓存）：**
```yaml
- name: Cache Node.js modules
  uses: actions/cache@v3
  with:
    path: |
      ~/.npm
      ./node_modules # For monorepos, cache specific project node_modules
    key: ${{ runner.os }}-node-${{ hashFiles('**/package-lock.json') }}-${{ github.run_id }}
    restore-keys: |
      ${{ runner.os }}-node-${{ hashFiles('**/package-lock.json') }}-
      ${{ runner.os }}-node-
```

### **2.并行化矩阵策略**
- **原理：** 跨多种配置（例如，不同的 Node.js 版本、操作系统、Python 版本、浏览器类型）并行运行作业，以加速测试和构建。
- **深入研究：**
    - **`strategy.matrix`:** 定义变量矩阵。
    - **`include`/`exclude`:** 微调组合。
    - **`fail-fast`:** 控制矩阵中的作业失败是否停止整个策略。
    - **最大化并发性：**非常适合同时跨各种环境运行测试。
- **副驾驶指南：**
    - 利用 `strategy.matrix` 同时针对不同环境、编程语言版本或操作系统测试应用程序。
    - 建议针对特定矩阵组合使用 `include` 和 `exclude` 以优化测试覆盖率，而无需运行不必要的运行。
    - 建议设置 `fail-fast: true`（默认）以快速反馈关键故障，或设置 `fail-fast: false` 以获得全面的测试报告。
- **示例（多版本、多操作系统测试矩阵）：**
```yaml
jobs:
  test:
    runs-on: ${{ matrix.os }}
    strategy:
      fail-fast: false # Run all tests even if one fails
      matrix:
        os: [ubuntu-latest, windows-latest]
        node-version: [16.x, 18.x, 20.x]
        browser: [chromium, firefox]
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-node@v3
        with:
          node-version: ${{ matrix.node-version }}
      - name: Install Playwright browsers
        run: npx playwright install ${{ matrix.browser }}
      - name: Run tests
        run: npm test
```

### **3.自托管运行器**
- **原则：** 将自托管运行器用于专用硬件、对私有资源的网络访问或 GitHub 托管运行器成本过高的环境。
- **深入研究：**
    - **自定义环境：** 非常适合大型构建缓存、特定硬件 (GPU) 或访问本地资源。
    - **成本优化：**对于非常高的使用率来说可以更具成本效益。
    - **安全注意事项：** 需要保护和维护您自己的基础设施、网络访问和更新。这包括适当强化运行机器、管理访问控制以及确保及时修补。
    - **可扩展性：** 规划自托管运行器如何根据需求进行扩展，手动或使用自动扩展解决方案。
- **副驾驶指南：**
    - 当 GitHub 托管的运行器不能满足特定的性能、成本、安全性或网络访问要求时，推荐自托管运行器。
    - 强调用户对保护、维护和扩展自托管运行器的责任，包括网络配置和定期安全审核。
    - 建议使用跑步者群组来有效地组织和管理自托管跑步者。

### **4.快速结帐和浅克隆**
- **原理：** 优化存储库签出时间以减少总体工作流程持续时间，特别是对于大型存储库。
- **深入研究：**
    - **`fetch-depth`:** 控制获取 Git 历史记录的量。对于大多数 CI/CD 构建来说 `1` 就足够了，因为通常只需要最新的提交。 `0` 的 `fetch-depth` 会获取整个历史记录，这很少需要，并且对于大型存储库来说可能会非常慢。
    - **`submodules`:** 如果特定作业不需要，请避免检出子模块。获取子模块会增加大量开销。
    - **`lfs`:** 高效管理 Git LFS（大文件存储）文件。如果不需要，请设置`lfs: false`。
    - **部分克隆：** 对于非常大的存储库，请考虑使用 Git 的部分克隆功能（`--filter=blob:none` 或 `--filter=tree:0`），尽管这通常是通过专门的操作或 Git 客户端配置来处理的。
- **副驾驶指南：**
    - 使用 `actions/checkout@v4` 和 `fetch-depth: 1` 作为大多数构建和测试作业的默认值，可以显着节省时间和带宽。
    - 仅当工作流程明确需要完整的 Git 历史记录（例如，用于发布标记、深度提交分析或 `git blame` 操作）时，才使用 `fetch-depth: 0`。
    - 如果工作流程的目的并非绝对必要，建议不要签出子模块 (`submodules: false`)。
    - 如果存储库中存在大型二进制文件，建议优化 LFS 使用。

### **5.用于作业间和工作流间通信的工件**
- **原理：** 有效地存储和检索构建输出（工件），以在同一工作流程内或不同工作流程的作业之间传递数据，确保数据持久性和完整性。
- **深入研究：**
    - **`actions/upload-artifact`:** 用于上传作业生成的文件或目录。工件会自动压缩并可以稍后下载。
    - **`actions/download-artifact`：** 用于下载后续作业或工作流程中的工件。您可以按名称下载所有工件或特定工件。
    - **`retention-days`：** 对于管理存储成本和合规性至关重要。根据工件的重要性和监管要求设置适当的保留期限。
    - **用例：** 构建输出（可执行文件、编译代码、Docker 映像）、测试报告（JUnit XML、HTML 报告）、代码覆盖率报告、安全扫描结果、生成的文档、静态网站构建。
    - **限制：** 工件一旦上传就不可更改。每个工件的最大大小可以是几 GB，但请注意存储成本。
- **副驾驶指南：**
    - 使用 `actions/upload-artifact@v3` 和 `actions/download-artifact@v3` 在同一工作流程内或不同工作流程的作业之间可靠地传递大文件，从而提高模块化和效率。
    - 为工件设置适当的 `retention-days` 来管理存储成本并确保旧工件被修剪。
    - 建议将测试报告、覆盖率报告和安全扫描结果作为工件上传，以便于访问、历史分析以及与外部报告工具集成。
    - 建议使用工件将编译的二进制文件或打包的应用程序从构建作业传递到部署作业，确保部署与构建和测试完全相同的工件。

## CI/CD 综合测试（扩展）

### **1.单元测试**
- **原则：** 对每个代码推送运行单元测试，以确保各个代码组件（函数、类、模块）独立地正确运行。它们是最快且数量最多的测试。
- **深入研究：**
    - **快速反馈：** 单元测试应该快速执行，为开发人员提供有关代码质量和正确性的即时反馈。强烈建议单元测试的并行化。
    - **代码覆盖率：** 集成代码覆盖率工具（例如，用于 JS 的 Istanbul、用于 Python 的 Coverage.py、用于 Java 的 JaCoCo）并强制执行最低覆盖率阈值。目标是高覆盖率，但要关注有意义的测试，而不仅仅是线路覆盖率。
    - **测试报告：** 使用 `actions/upload-artifact`（例如 JUnit XML 报告）或与 GitHub Checks/Annotations 集成的特定测试报告操作发布测试结果。
    - **模拟和存根：** 强调使用模拟和存根将测试中的单元与其依赖项隔离。
- **副驾驶指南：**
    - 配置专用作业以在 CI 管道的早期运行单元测试，最好在每个 `push` 和 `pull_request` 上触发。
    - 使用适当的特定于语言的测试运行程序和框架（Jest、Vitest、Pytest、Go 测试、JUnit、NUnit、XUnit、RSpec）。
    - 建议收集和发布代码覆盖率报告，并与 Codecov、Coveralls 或 SonarQube 等服务集成以进行趋势分析。
    - 建议并行单元测试的策略以减少执行时间。

### **2.集成测试**
- **原理：** 运行集成测试来验证不同组件或服务之间的交互，确保它们按预期协同工作。这些测试通常涉及真正的依赖关系（例如数据库、API）。
- **深入研究：**
    - **服务配置：** 在作业中使用 `services` 通过 Docker 容器启动临时数据库、消息队列、外部 API 或其他依赖项。这提供了一致且隔离的测试环境。
    - **测试替身与真实服务：** 在模拟外部服务进行纯单元测试和使用真实的轻量级实例进行更现实的集成测试之间取得平衡。测试实际集成点时优先考虑真实实例。
    - **测试数据管理：** 管理测试数据的计划，确保测试可重复，并在运行之间清理或重置数据。
    - **执行时间：** 集成测试通常比单元测试慢。优化它们的执行并考虑比单元测试更频繁地运行它们（例如，在 PR 合并时而不是每次推送时）。
- **副驾驶指南：**
    - 在测试期间使用工作流定义中的 `services` 或 Docker Compose 来提供必要的服务（例如 PostgreSQL/MySQL 等数据库、RabbitMQ/Kafka 等消息队列、Redis 等内存缓存）。
    - 建议在单元测试之后、E2E 测试之前运行集成测试，以便及早发现集成问题。
    - 提供有关如何在 GitHub Actions 工作流程中设置 `service` 容器的示例。
    - 提出为集成测试运行创建和清理测试数据的策略。

### **3.端到端 (E2E) 测试**
- **原理：** 模拟完整的用户行为，以验证从 UI 到后端的整个应用程序流程，确保整个系统从用户的角度按预期工作。
- **深入研究：**
    - **工具：** 使用现代 E2E 测试框架，例如 Cypress、Playwright 或 Selenium。这些提供了浏览器自动化功能。
    - **暂存环境：** 理想情况下，针对紧密反映生产的已部署暂存环境运行 E2E 测试，以实现最大保真度。避免直接在 CI 中运行，除非资源是专用和隔离的。
    - **不稳定缓解：**通过显式等待、强大的选择器、失败测试重试以及仔细的测试数据管理来主动解决不稳定问题。不稳定的测试会削弱人们对管道的信任。
    - **视觉回归测试：** 考虑集成视觉回归测试（例如 Applitools、Percy）以捕获 UI 差异。
    - **报告：** 捕获失败的屏幕截图和视频记录以帮助调试。
- **副驾驶指南：**
    - 使用 Cypress、Playwright 或 Selenium 等工具进行 E2E 测试，并在 GitHub Actions 中提供有关其设置的指导。
    - 建议针对已部署的临时环境运行 E2E 测试，以便在生产之前发现问题并验证完整的部署过程。
    - 配置失败时的测试报告、视频录制和屏幕截图，以帮助调试并为测试结果提供更丰富的上下文。
    - 就尽量减少 E2E 测试不稳定的策略提供建议，例如稳健的元素选择和重试机制。

### **4.性能和负载测试**
- **原则：** 评估预期负载和峰值负载条件下的应用程序性能和行为，以识别瓶颈、确保可扩展性并防止回归。
- **深入研究：**
    - **工具：** JMeter、k6、Locust、加特林、火炮。根据语言、复杂性和特定需求进行选择。
    - **集成：** 集成到 CI/CD 中以进行持续性能回归检测。运行这些测试的频率低于单元/集成测试（例如，每晚、每周或在重要功能合并时）。
    - **阈值：** 定义明确的性能阈值（例如响应时间、吞吐量、错误率），如果超出这些阈值，则构建失败。
    - **基线比较：** 将当前性能指标与既定基线进行比较，以检测性能下降情况。
- **副驾驶指南：**
    - 建议将性能和负载测试集成到关键应用程序的 CI 管道中，并提供常用工具的示例。
    - 建议设置性能基线，并在性能下降超出设定阈值时使构建失败。
    - 建议在模拟生产负载模式的专用环境中运行这些测试。
    - 分析性能测试结果以查明优化领域（例如数据库查询、API 端点）的指南。

### **5.测试报告和可见性**
- **原则：** 让所有利益相关者（开发人员、QA、产品负责人）能够轻松访问、理解和查看测试结果，以提高透明度并快速解决问题。
- **深入研究：**
    - **GitHub 检查/注释：** 在拉取请求中直接利用这些进行内联反馈，显示哪些测试通过/失败，并提供详细报告的链接。
    - **工件：** 上传全面的测试报告（JUnit XML、HTML 报告、代码覆盖率报告、视频记录、屏幕截图）作为工件，以进行长期存储和详细检查。
    - **与仪表板集成：** 将结果推送到外部仪表板或报告工具（例如 SonarQube、自定义报告工具、Allure Report、TestRail）以获取聚合视图和历史趋势。
    - **状态徽章：** 在 README 中使用 GitHub Actions 状态徽章来一目了然地指示最新的构建/测试状态。
- **副驾驶指南：**
    - 使用将测试结果作为注释发布或检查 PR 的操作，以便直接在 GitHub UI 中获得即时反馈和轻松调试。
    - 上传详细的测试报告（例如 XML、HTML、JSON）作为工件以供以后检查和历史分析，包括错误屏幕截图等负面结果。
    - 建议与外部报告工具集成，以更全面地了解测试执行趋势和质量指标。
    - 建议将工作流状态徽章添加到自述文件中，以便快速查看 CI/CD 运行状况。

## 高级部署策略（扩展）

### **1.暂存环境部署**
- **原则：** 部署到与生产密切相关的临时环境，以进行全面验证、用户验收测试 (UAT) 以及升级到生产之前的最终检查。
- **深入研究：**
    - **镜像生产：** 分期应在基础设施、数据、配置和安全性方面密切模仿生产。任何重大差异都可能导致生产问题。
    - **自动升级：** 在成功的 UAT 和必要的手动批准后，实施从暂存到生产的自动升级。这减少了人为错误并加快了发布速度。
    - **环境保护：** 使用 GitHub Actions 中的环境保护规则来防止意外部署、强制执行手动审批以及限制哪些分支可以部署到暂存。
    - **数据刷新：** 定期刷新生产中的暂存数据（必要时匿名），以确保真实的测试场景。
- **副驾驶指南：**
    - 创建专用的 `environment` 用于暂存，并具有批准规则、秘密保护和适当的分支保护策略。
    - 设计工作流程以在成功合并到特定开发或发布分支（例如 `develop`、`release/*`）时自动部署到暂存。
    - 建议确保登台环境尽可能接近生产，以最大限度地提高测试保真度。
    - 建议在分阶段实施自动化冒烟测试和部署后验证。

### **2.生产环境部署**
- **原则：** 仅在彻底验证、可能经过多层手动批准和强大的自动检查、优先考虑稳定性和零停机时间后才部署到生产。
- **深入研究：**
    - **手动批准：** 对于生产部署至关重要，通常涉及多个团队成员、安全签核或变更管理流程。 GitHub 环境本身就支持这一点。
    - **回滚功能：** 对于从不可预见的问题中快速恢复至关重要。确保以快速可靠的方式恢复到之前的稳定状态。
    - **部署期间的可观察性：**在部署期间和部署之后立即密切监控生产是否存在任何异常或性能下降。使用仪表板、警报和跟踪。
    - **渐进式交付：** 考虑先进的技术，例如蓝/绿、金丝雀或黑暗启动，以实现更安全的部署。
    - **紧急部署：** 为关键修补程序建立一个单独的、高度快速的管道，绕过非必要的批准，但仍保持安全检查。
- **副驾驶指南：**
    - 为生产创建专用的 `environment` ，并提供所需的审阅者、严格的分支保护和清晰的部署窗口。
    - 对生产部署实施手动审批步骤，可能与外部 ITSM 或变更管理系统集成。
    - 强调在部署失败的情况下清晰、经过充分测试的回滚策略和自动回滚程序的重要性。
    - 建议为生产系统建立全面的监控和警报，以便在部署后立即检测和响应问题。

### **3.部署类型（超出基本滚动更新）**
- **滚动更新（部署默认）：** 逐渐用新版本的实例替换旧版本的实例。适用于大多数情况，尤其是无状态应用程序。
    - **指南：** 配置 `maxSurge`（可以在所需副本计数之上创建多少个新实例）和 `maxUnavailable`（可以有多少旧实例不可用），以对部署速度和可用性进行细粒度控制。
- **蓝/绿部署：** 在单独的环境中与现有稳定版本（蓝色）一起部署新版本（绿色），然后将流量完全从蓝色切换为绿色。
    - **指南：** 建议需要零停机发布和轻松回滚的关键应用程序。需要管理两个相同的环境和一个流量路由器（负载均衡器、入口控制器、DNS）。
    - **好处：** 通过将流量切换回蓝色环境实现瞬时回滚。
- **金丝雀部署：** 在全面推出之前，逐步向一小部分用户（例如 5-10%）推出新版本。监控金丝雀组的性能和错误率。
    - **指南：** 建议使用受控爆炸半径来测试新功能或更改。使用支持流量拆分和基于指标的分析的服务网格（Istio、Linkerd）或入口控制器来实施。
    - **优点：** 及早发现问题，对用户的影响最小。
- **暗启动/功能标志：**部署新代码，但对用户隐藏功能，直到通过功能标志为特定用户/组打开。
    - **指南：** 建议将部署与发布分离，允许持续交付而无需持续暴露新功能。使用功能标记管理系统（LaunchDarkly、Split.io、Unleash）。
    - **优点：** 降低部署风险，支持 A/B 测试，并允许分阶段部署。
- **A/B 测试部署：** 将功能的多个版本同时部署到不同的用户群，以根据用户行为和业务指标比较其性能。
    - **指南：** 建议与专门的 A/B 测试平台集成或使用功能标志和分析构建自定义逻辑。

### **4.回滚策略和事件响应**
- **原则：** 在出现问题时能够快速安全地恢复到以前的稳定版本，最大限度地减少停机时间和业务影响。这需要积极主动的规划。
- **深入研究：**
    - **自动回滚：** 实施基于监控警报（例如，错误突然增加、高延迟）或部署后运行状况检查失败自动触发回滚的机制。
    - **版本化工件：** 确保以前成功的构建工件、Docker 映像或基础设施状态随时可用且易于部署。这对于快速恢复至关重要。
    - **运行手册：** 记录清晰、简洁且可执行的回滚过程，以便在自动化不够或复杂的情况下进行手动干预。应定期审查和测试这些内容。
    - **事件后审查：** 进行无过错的事件后审查 (PIR)，以了解故障的根本原因、吸取经验教训并实施预防措施，以提高弹性并缩短 MTTR。
    - **沟通计划：** 在事件和回滚期间为利益相关者制定清晰的沟通计划。
- **副驾驶指南：**
    - 指导用户存储以前成功的构建工件和映像以便快速恢复，确保它们具有版本控制且易于检索。
    - 建议在管道中实施由监控或运行状况检查失败触发的自动回滚步骤，并提供示例。
    - 强调在构建应用程序时牢记“撤消”，这意味着更改应该可以轻松逆转。
    - 建议为常见事件场景创建全面的操作手册，包括分步回滚说明，并强调它们对 MTTR 的重要性。
    - 有关设置足够具体且可操作以触发自动或手动回滚的警报的指南。

## GitHub Actions 工作流程审核清单（综合）

此清单提供了一组细化的标准，用于审查 GitHub Actions 工作流程，以确保它们遵循安全性、性能和可靠性的最佳实践。

- [ ] **总体结构和设计：**
    - 工作流程 `name` 是否清晰、描述性且独特？
    - `on` 触发器是否适合工作流程的目的（例如，`push`、`pull_request`、`workflow_dispatch`、`schedule`）？路径/分支过滤器是否有效使用？
    - `concurrency` 是否用于关键工作流程或共享资源以防止竞争条件或资源耗尽？
    - 全局 `permissions` 是否设置为最小权限原则（默认为 `contents: read` ），并针对作业进行特定覆盖？
    - 是否利用可重用工作流程 (`workflow_call`) 来实现常见模式以减少重复并提高可维护性？
    - 工作流程是否以有意义的作业和步骤名称进行逻辑组织？

- [ ] **作业和步骤最佳实践：**
    - 作业是否明确命名并代表不同的阶段（例如 `build`、`lint`、`test`、`deploy`）？
    - 作业之间是否正确定义了 `needs` 依赖关系以确保正确的执行顺序？
    - `outputs` 是否有效地用于作业间和工作流间通信？
    - `if` 条件是否有效用于条件作业/步骤执行（例如，特定于环境的部署、特定于分支的操作​​）？
    - 所有 `uses` 操作是否都经过安全版本控制（固定到完整提交 SHA 或特定的主要版本标签，如 `@v4`）？避免使用 `main` 或 `latest` 标签。
    - `run` 命令是否高效且干净（与 `&&` 结合，删除临时文件，多行脚本格式清晰）？
    - 环境变量 (`env`) 是否在适当的范围（工作流程、作业、步骤）中定义，并且从未硬编码敏感数据？
    - 是否为长时间运行的作业设置 `timeout-minutes` 以防止工作流程挂起？

- [ ] **安全考虑：**
    - 所有敏感数据是否仅通过 GitHub `secrets` 上下文 (`${{ secrets.MY_SECRET }}`) 访问？永远不会硬编码，永远不会在日志中暴露（即使被屏蔽）。
    - 是否尽可能使用 OpenID Connect (OIDC) 进行云身份验证，从而消除长期凭据？
    - `GITHUB_TOKEN` 权限范围是否明确定义并限制为最低必要访问权限（`contents: read` 作为基线）？
    - 是否集成了软件组合分析 (SCA) 工具（例如 `dependency-review-action`、Snyk）来扫描易受攻击的依赖项？
    - 是否集成了静态应用程序安全测试 (SAST) 工具（例如 CodeQL、SonarQube）来扫描源代码中的漏洞，并通过关键发现阻止构建？
    - 是否为存储库启用了秘密扫描，并且是否建议使用预提交挂钩来防止本地凭据泄漏？
    - 如果使用容器映像，是否有针对容器映像签名（例如，Notary、Cosign）和部署工作流程中的验证的策略？
    - 对于自托管运行程序，是否遵循安全强化准则并限制网络访问？

- [ ] **优化和性能：**
    - 缓存 (`actions/cache`) 是否有效地用于包管理器依赖项（`node_modules`、`pip` 缓存、Maven/Gradle 缓存）和构建输出？
    - 缓存 `key` 和 `restore-keys` 是否旨在实现最佳缓存命中率（例如，使用 `hashFiles`）？
    - `strategy.matrix` 是否用于跨不同环境、语言版本或操作系统的并行测试或构建？
    - `fetch-depth: 1` 是否用于不需要完整 Git 历史记录的 `actions/checkout` ？
    - 工件（`actions/upload-artifact`、`actions/download-artifact`）是否有效地用于在作业/工作流之间传输数据，而不是重新构建或重新获取？
    - 是否使用 Git LFS 管理大文件并在必要时针对签出进行优化？

- [ ] **测试策略整合：**
    - 全面的单元测试是否在早期就配置了专门的作业？
    - 是否定义了集成测试，最好利用 `services` 作为依赖项，并在单元测试后运行？
    - 是否包括端到端（E2E）测试，最好是针对临时环境，并具有强大的片状缓解功能？
    - 是否针对具有定义阈值的关键应用程序集成了性能和负载测试？
    - 是否收集了所有测试报告（JUnit XML、HTML、覆盖率）、将其作为工件发布并集成到 GitHub Checks/Annotations 中以获得清晰可见性？
    - 是否以最低阈值跟踪和执行代码覆盖率？

- [ ] **部署策略和可靠性：**
    - 使用 GitHub `environment` 规则的暂存和生产部署是否具有适当的保护（手动批准、所需的审阅者、分支限制）？
    - 是否为敏感生产部署配置了手动审批步骤？
    - 是否制定了明确且经过充分测试的回滚策略，并在可能的情况下实现自动化（例如，`kubectl rollout undo`，恢复到以前的稳定映像）？
    - 所选的部署类型（例如滚动、蓝/绿、金丝雀、黑暗启动）是否适合应用程序的关键性和风险承受能力？
    - 是否实施部署后健康检查和自动冒烟测试来验证部署是否成功？
    - 工作流程是否能够应对临时故障（例如，重试不稳定的网络操作）？

- [ ] **可观察性和监控：**
    - 日志记录是否足以调试工作流程故障（使用 STDOUT/STDERR 作为应用程序日志）？
    - 是否收集并公开相关应用程序和基础设施指标（例如 Prometheus 指标）？
    - 是否针对生产中检测到的关键工作流程故障、部署问题或应用程序异常配置了警报？
    - 是否集成了分布式跟踪（例如 OpenTelemetry、Jaeger）以了解微服务架构中的请求流？
    - 工件 `retention-days` 是否已适当配置以管理存储和合规性？

## 对常见 GitHub Actions 问题进行故障排除（深入探讨）

本部分提供了诊断和解决使用 GitHub Actions 工作流程时遇到的常见问题的扩展指南。

### **1.工作流程未触发或意外跳过作业/步骤**
- **根本原因：** `on` 触发器不匹配、`paths` 或 `branches` 过滤器不正确、`if` 条件错误或 `concurrency` 限制。
- **可行步骤：**
    - **验证触发器：**
        - 检查 `on` 块是否与应触发工作流程的事件完全匹配（例如，`push`、`pull_request`、`workflow_dispatch`、`schedule`）。
        - 确保正确定义 `branches`、`tags` 或 `paths` 过滤器并与事件上下文匹配。请记住，`paths-ignore` 和 `branches-ignore` 优先。
        - 如果使用 `workflow_dispatch`，请验证工作流文件是否位于默认分支中，并且在手动触发期间正确提供了任何所需的 `inputs`。
    - **检查 `if` 条件：**
        - 仔细检查工作流程、作业和步骤级别的所有 `if` 条件。单个错误条件可能会阻止执行。
        - 在调试步骤中使用 `always()` 来打印上下文变量（`${{ toJson(github) }}`、`${{ toJson(job) }}`、`${{ toJson(steps) }}`），以了解评估期间的确切状态。
        - 在简化的工作流程中测试复杂的 `if` 条件。
    - **检查`concurrency`：**
        - 如果定义了 `concurrency`，请验证先前的运行是否阻止同一组的新运行。检查工作流运行中的“并发”选项卡。
    - **分支保护规则：** 确保没有分支保护规则阻止工作流在某些分支上运行或要求未通过的特定检查。

### **2.权限错误（`Resource not accessible by integration`、`Permission denied`）**
- **根本原因：** `GITHUB_TOKEN` 缺乏必要的权限、环境机密访问不正确或外部操作权限不足。
- **可行步骤：**
    - **`GITHUB_TOKEN` 权限：**
        - 在工作流程和作业级别查看 `permissions` 块。全局默认为 `contents: read` ，仅在绝对必要时授予特定写入权限（例如， `pull-requests: write` 用于更新 PR 状态， `packages: write` 用于发布包）。
        - 了解 `GITHUB_TOKEN` 的默认权限通常过于宽泛。
    - **秘密访问：**
        - 验证是否在存储库、组织或环境设置中正确配置了机密。
        - 如果使用环境机密，请确保工作流程/作业可以访问特定环境。检查环境是否有任何等待手动批准的情况。
        - 确认秘密名称完全匹配 (`secrets.MY_API_KEY`)。
    - **OIDC 配置：**
        - 对于基于 OIDC 的云身份验证，请仔细检查云提供商中的信任策略配置（AWS IAM 角色、Azure AD 应用程序注册、GCP 服务帐户），以确保其正确信任 GitHub 的 OIDC 颁发者。
        - 验证分配的角色/身份是否具有访问云资源所需的权限。

### **3.缓存问题（`Cache not found`、`Cache miss`、`Cache creation failed`）**
- **根本原因：** 缓存键逻辑不正确、`path` 不匹配、缓存大小限制或频繁缓存失效。
- **可行步骤：**
    - **验证缓存密钥：**
        - 验证 `key` 和 `restore-keys` 是否正确，并且仅当依赖项真正发生变化时才动态更改（例如，`key: ${{ runner.os }}-node-${{ hashFiles('**/package-lock.json') }}`）。过于动态的缓存键总是会导致丢失。
        - 使用 `restore-keys` 为轻微变化提供回退，增加缓存命中机会。
    - **检查`path`：**
        - 确保 `actions/cache` 中指定的用于保存和恢复的 `path` 与安装依赖项或生成工件的目录完全对应。
        - 在缓存之前验证 `path` 是否存在。
    - **调试缓存行为：**
        - 使用 `actions/cache/restore` 操作和 `lookup-only: true` 来检查正在尝试哪些键以及为什么会发生缓存未命中，而不影响构建。
        - 查看工作流程日志中的 `Cache hit` 或 `Cache miss` 消息及关联键。
    - **缓存大小和限制：** 请注意每个存储库的 GitHub Actions 缓存大小限制。如果缓存非常大，它们可能会被频繁驱逐。

### **4.长时间运行的工作流程或超时**
- **根本原因：** 步骤效率低、缺乏并行性、依赖性大、未优化的 Docker 映像构建或运行器上的资源瓶颈。
- **可行步骤：**
    - **配置文件执行时间：**
        - 使用工作流运行摘要来识别运行时间最长的作业和步骤。这是您优化的主要工具。
    - **优化步骤：**
        - 将 `run` 命令与 `&&` 相结合，以减少 Docker 构建中的层创建和开销。
        - 使用后立即清理临时文件（同一 `RUN` 命令中的 `rm -rf`）。
        - 仅安装必要的依赖项。
    - **利用缓存：**
        - 确保针对所有重要依赖项和构建输出对 `actions/cache` 进行最佳配置。
    - **与矩阵策略并行：**
        - 使用 `strategy.matrix` 将测试分解或构建为更小的可并行单元以同时运行它们。
    - **选择合适的跑步者：**
        - 查看 `runs-on`。对于资源非常密集的任务，请考虑使用更大的 GitHub 托管运行器（如果可用）或具有更强大规格的自托管运行器。
    - **分解工作流程：**
        - 对于非常复杂或较长的工作流程，请考虑将它们分解为较小的、独立的工作流程，这些工作流程相互触发或使用可重用的工作流程。

### **5. CI 中的不稳定测试 (`Random failures`, `Passes locally, fails in CI`)**
- **根本原因：** 不确定性测试、竞争条件、本地和 CI 之间的环境不一致、对外部服务的依赖或不良的测试隔离。
- **可行步骤：**
    - **确保测试隔离：**
        - 确保每个测试都是独立的，并且不依赖于先前测试留下的状态。每次测试或测试套件后清理资源（例如数据库条目）。
    - **消除竞争条件：**
        - 对于集成/E2E 测试，请使用显式等待（例如，等待元素可见、等待 API 响应）而不是任意 `sleep` 命令。
        - 对与外部服务交互或出现暂时故障的操作实施重试。
    - **标准化环境：**
        - 确保 CI 环境（Node.js 版本、Python 包、数据库版本）尽可能与本地开发环境匹配。
        - 使用 Docker `services` 来获得一致的测试依赖项。
    - **稳健的选择器 (E2E)：**
        - 在 E2E 测试中使用稳定、独特的选择器（例如 `data-testid` 属性），而不是脆弱的 CSS 类或 XPath。
    - **调试工具：**
        - 配置端到端测试框架以捕获 CI 中测试失败的屏幕截图和视频记录，以直观地诊断问题。
    - **独立运行不稳定的测试：**
        - 如果测试始终不稳定，请将其隔离并重复运行以识别潜在的非确定性行为。

### **6。部署失败（应用程序部署后不工作）**
- **根本原因：** 配置漂移、环境差异、缺少运行时依赖项、应用程序错误或部署后的网络问题。
- **可行步骤：**
    - **彻底的日志审查：**
        - 检查部署日志（`kubectl logs`、应用程序日志、服务器日志），以了解部署过程中和部署后的任何错误消息、警告或意外输出。
    - **配置验证：**
        - 验证注入已部署应用程序的环境变量、ConfigMap、Secret 和其他配置。确保它们符合目标环境的要求并且没有丢失或格式错误。
        - 使用部署前检查来验证配置。
    - **依赖性检查：**
        - 确认所有应用程序运行时依赖项（库、框架、外部服务）已正确捆绑在容器映像中或安装在目标环境中。
    - **部署后健康检查：**
        - 在部署后实施强大的自动化冒烟测试和运行状况检查，以立即验证核心功能和连接性。如果失败则触发回滚。
    - **网络连接：**
        - 检查新环境中已部署组件（例如，应用程序到数据库、服务到服务）之间的网络连接。查看防火墙规则、安全组和 Kubernetes 网络策略。
    - **立即回滚：**
        - 如果生产部署失败或导致降级，立即触发回滚策略以恢复服务。在非生产环境中诊断问题。

## 结论

GitHub Actions 是一个强大而灵活的平台，用于自动化软件开发生命周期。通过严格应用这些最佳实践（从保护您的机密和令牌权限，到通过缓存和并行化优化性能，以及实施全面的测试和强大的部署策略），您可以指导开发人员构建高效、安全且可靠的 CI/CD 管道。请记住，CI/CD 是一个迭代过程；持续测量、优化和保护您的管道，以实现更快、更安全、更自信的发布。您的详细指导将使团队能够充分利用 GitHub Actions 的潜力并充满信心地交付高质量的软件。这份内容广泛的文档可以作为任何希望通过 GitHub Actions 掌握 CI/CD 的人的基础资源。

---

<!-- GitHub Actions CI/CD 最佳实践说明结束 -->

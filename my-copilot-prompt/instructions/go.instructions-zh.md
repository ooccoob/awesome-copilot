---
描述：“按照惯用的 Go 实践和社区标准编写 Go 代码的说明”
applyTo: '**/*.go,**/go.mod,**/go.sum'
---

# Go开发说明

编写 Go 代码时遵循惯用的 Go 实践和社区标准。这些说明基于 [Effective Go](https://go.dev/doc/effective_go)、[Go 代码审查评论](https://go.dev/wiki/CodeReviewComments) 和 [Google 的 Go 风格指南](https://google.github.io/styleguide/go/)。

## 一般说明

- 编写简单、清晰、惯用的 Go 代码
- 优先考虑清晰和简单而不是聪明
- 遵循最小惊喜原则
- 保持快乐路径左对齐（最小化缩进）
- 尽早返回以减少筑巢
- 更喜欢提前返回而不是 if-else 链；使用 `if condition { return }` 模式来避免 else 块
- 让零值变得有用
- 使用清晰的描述性名称编写自记录代码
- 记录导出的类型、函数、方法和包
- 使用 Go 模块进行依赖管理
- 利用 Go 标准库而不是重新发明轮子（例如，使用 `strings.Builder` 进行字符串连接，使用 `filepath.Join` 进行路径构造）
- 当功能存在时，优先选择标准库解决方案而不是自定义实现
- 默认用英文写评论；仅根据用户请求进行翻译
- 避免在代码和注释中使用表情符号

## 命名约定

### 套餐

- 使用小写、单字包名称
- 避免使用下划线、连字符或混合大写字母
- 选择描述包提供的内容而不是其包含的内容的名称
- 避免使用 `util`、`common` 或 `base` 等通用名称
- 包名称应该是单数，而不是复数

#### 包裹申报规则（重要）：
- **永远不要重复 `package` 声明** - 每个 Go 文件必须恰好有一个 `package` 行
- 编辑现有 `.go` 文件时：
  - **保留**现有的 `package` 声明 - 不要添加另一个声明
  - 如果需要替换整个文件内容，请从现有的包名开始
- 创建新的 `.go` 文件时：
  - **在编写任何代码之前**，检查同一目录中其他 `.go` 文件使用的包名称
  - 使用与该目录中现有文件相同的包名称
  - 如果是新目录，则使用目录名作为包名
  - 在文件的最顶部写入**恰好一个** `package <name>` 行
- 使用文件创建或替换工具时：
  - **始终验证** 在添加目标文件之前是否已有 `package` 声明
  - 如果替换文件内容，请在新内容中仅包含一个 `package` 声明
  - **切勿** 创建具有多个 `package` 行或重复声明的文件

### 变量和函数

- 使用混合大写字母或混合大写字母（驼峰式）而不是下划线
- 保持名称简短但具有描述性
- 仅在非常短的范围内使用单字母变量（例如循环索引）
- 导出的名称以大写字母开头
- 未导出的名称以小写字母开头
- 避免口吃（例如，避免 `http.HTTPServer`，更喜欢 `http.Server`）

### 接口

- 尽可能使用 -er 后缀命名接口（例如 `Reader`、`Writer`、`Formatter`）
- 单方法接口应以方法命名（例如 `Read` → `Reader`）
- 保持界面小而集中

### 常数

- 对导出的常量使用 MixedCaps
- 对未导出的常量使用mixedCaps
- 使用 `const` 块对相关常量进行分组
- 考虑使用类型常量以获得更好的类型安全性

## 代码风格和格式

### 格式化

- 始终使用 `gofmt` 来格式化代码
- 使用 `goimports` 自动管理导入
- 保持行长合理（无硬性限制，但考虑可读性）
- 添加空行以分隔逻辑代码组

### 评论

- 努力实现自文档化代码；与注释相比，更喜欢清晰的变量名称、函数名称和代码结构
- 仅在需要解释复杂逻辑、业务规则或不明显行为时才编写注释
- 默认用英文写完整句子的评论
- 仅根据特定用户请求将评论翻译为其他语言
- 以所描述事物的名称开始句子
- 包注释应以“包[名称]”开头
- 大多数注释使用行注释 (`//`)
- 谨慎使用块注释 (`/* */`)，主要用于包文档
- 记录原因，而不是内容，除非内容很复杂
- 避免在注释和代码中使用表情符号

### 错误处理

- 函数调用后立即检查错误
- 不要使用 `_` 忽略错误，除非你有充分的理由（记录原因）
- 使用 `fmt.Errorf` 和 `%w` 动词将错误与上下文一起包装
- 当您需要检查特定错误时创建自定义错误类型
- 地点错误作为最后的返回值返回
- 命名错误变量 `err`
- 错误消息保持小写并且不以标点符号结尾

## 架构和项目结构

### 包装组织

- 遵循标准 Go 项目布局约定
- 将 `main` 包保留在 `cmd/` 目录中
- 将可重用包放入 `pkg/` 或 `internal/` 中
- 对不应由外部项目导入的包使用 `internal/`
- 将相关功能分组到包中
- 避免循环依赖

### 依赖管理

- 使用 Go 模块（`go.mod` 和 `go.sum`）
- 保持最小的依赖关系
- 定期更新安全补丁的依赖项
- 使用 `go mod tidy` 清理未使用的依赖项
- 仅在必要时依赖供应商

## 类型安全和语言特性

### 类型定义

- 定义类型以添加含义和类型安全性
- 使用结构标签进行 JSON、XML、数据库映射
- 更喜欢显式类型转换
- 小心使用类型断言并检查第二个返回值
- 与不受约束的类型相比，更喜欢泛型；当真正需要不受约束的类型时，请使用预先声明的别名 `any` 而不是 `interface{}` (Go 1.18+)

### 指针与值

- 对于大型结构或需要修改接收器时使用指针接收器
- 对于小型结构以及需要不变性时使用值接收器
- 当需要修改参数或大型结构时，请使用指针参数
- 当您想要防止修改时，请对小型结构使用值参数
- 在类型的方法集中保持一致
- 选择指针与值接收器时考虑零值

### 接口和组成

- 接受接口，返回具体类型
- 保持接口较小（1-3 种方法是理想的）
- 使用嵌入进行组合
- 在靠近使用位置而不是实现位置定义接口
- 除非必要，否则不要导出接口

## 并发性

### Goroutine

- 在库中创建 goroutine 时要小心；更喜欢让调用者控制并发
- 如果必须在库中创建 goroutine，请提供清晰的文档和清理机制
- 始终知道 goroutine 将如何退出
- 使用 `sync.WaitGroup` 或通道来等待 goroutine
- 通过确保清理来避免 goroutine 泄漏

### 渠道

- 使用通道在 goroutine 之间进行通信
- 不要通过共享内存来交流；通过通信共享内存
- 从发送方而不是接收方关闭通道
- 当您知道容量时使用缓冲通道
- 使用 `select` 进行非阻塞操作

### 同步

- 使用 `sync.Mutex` 保护共享状态
- 保持关键部分较小
- 当你有很多读者时使用 `sync.RWMutex`
- 根据用例选择通道和互斥体：使用通道进行通信，使用互斥体保护状态
- 使用 `sync.Once` 进行一次性初始化
- Go 版本的 WaitGroup 使用情况：
	- 如果 `go.mod` 中存在 `go >= 1.25`，则使用新的 `WaitGroup.Go` 方法（[文档](https://pkg.go.dev/sync#WaitGroup)）：
		```go
		var wg sync.WaitGroup
		wg.Go(task1)
		wg.Go(task2)
		wg.Wait()
		```
	- 如果是 `go < 1.25`，则使用经典的 `Add`/`Done` 模式

## 错误处理模式

### 制造错误

- 使用 `errors.New` 来处理简单的静态错误
- 使用 `fmt.Errorf` 来处理动态错误
- 为特定于域的错误创建自定义错误类型
- 导出标记错误的错误变量
- 使用 `errors.Is` 和 `errors.As` 进行错误检查

### 误差传播

- 在堆栈中传播错误时添加上下文
- 不记录并返回错误（选择一项）
- 在适当的级别处理错误
- 考虑使用结构化错误来更好地调试

## API设计

### HTTP 处理程序

- 对简单处理程序使用 `http.HandlerFunc`
- 为需要状态的处理程序实现 `http.Handler`
- 使用中间件来解决横切问题
- 设置适当的状态代码和标头
- 优雅地处理错误并返回适当的错误响应
- Go 版本的路由器使用情况：
	- 如果是 `go >= 1.22`，则更喜欢具有基于模式的路由和方法匹配的增强型 `net/http` `ServeMux`
	- 如果是 `go < 1.22`，请使用经典的 `ServeMux` 并手动处理方法/路径（或在合理时使用第三方路由器）

### JSON API

- 使用结构标签来控制 JSON 封送
- 验证输入数据
- 对可选字段使用指针
- 考虑使用 `json.RawMessage` 进行延迟解析
- 适当处理 JSON 错误

### HTTP 客户端

- 让客户端结构仅关注配置和依赖项（例如，基本 URL、`*http.Client`、auth、默认标头）。它不能存储每个请求的状态
- 不要在客户端结构中存储或缓存 `*http.Request` ，并且不要跨调用保留请求特定的状态；相反，为每个方法调用构造一个新的请求
- 方法应该接受 `context.Context` 和输入参数，在本地组装 `*http.Request` （或通过每次调用创建的短期构建器/帮助程序），然后调用 `c.httpClient.Do(req)`
- 如果重用请求构建逻辑，请将其分解到未导出的辅助函数或每次调用构建器类型中；永远不要将 `http.Request` （URL 参数、正文、标头）保留为长期客户端上的字段
- 确保底层 `*http.Client` 已配置（超时、传输）并且可以安全地并发使用；避免在首次使用后改变 `Transport`
- 始终在您发送的请求实例上设置标头，并关闭响应正文 (`defer resp.Body.Close()`)，适当处理错误

## 性能优化

### 内存管理

- 最小化热路径中的分配
- 尽可能重用对象（考虑 `sync.Pool`）
- 对小型结构使用值接收器
- 当大小已知时预分配切片
- 避免不必要的字符串转换

### I/O：读取器和缓冲区

- 大多数 `io.Reader` 流只能使用一次；阅读进度状态。不要假设读者可以在没有特殊处理的情况下重新阅读
- 如果必须多次读取数据，请缓冲一次并根据需要重新创建读取器：
	- 使用 `io.ReadAll` （或有限读取）获取 `[]byte`，然后通过 `bytes.NewReader(buf)` 或 `bytes.NewBuffer(buf)` 创建新的读取器以供每次重用
	- 对于字符串，请使用 `strings.NewReader(s)`；您可以在 `*bytes.Reader` 上使用 `Seek(0, io.SeekStart)` 来倒回
- 对于 HTTP 请求，不要重复使用已使用的 `req.Body`。相反：
	- 将原始有效负载保留为 `[]byte` 并在每次发送之前设置 `req.Body = io.NopCloser(bytes.NewReader(buf))`
	- 最好配置 `req.GetBody` ，以便传输可以重新创建重定向/重试的正文： `req.GetBody = func() (io.ReadCloser, error) { return io.NopCloser(bytes.NewReader(buf)), nil }`
- 要在读取时复制流，请使用 `io.TeeReader` （在传递时复制到缓冲区）或使用 `io.MultiWriter` 写入多个接收器
- 重用缓冲读取器：调用 `(*bufio.Reader).Reset(r)` 附加到新的底层读取器；不要指望它会“倒带”，除非源支持寻找
- 对于大的有效负载，避免无限制的缓冲；考虑流式传输、`io.LimitReader` 或磁盘临时存储来控制内存

- 使用 `io.Pipe` 进行流式传输而不缓冲整个有效负载：
	- 当读取器消费时，在单独的 goroutine 中写入 `*io.PipeWriter`
	- 始终关闭 writer；失败时使用 `CloseWithError(err)`
	- `io.Pipe` 用于流式传输，而不是倒带或使读取器可重用

- **警告：** 使用 `io.Pipe` 时（尤其是使用多部分编写器），所有写入必须严格按顺序执行。不要同时写入或乱序写入 - 必须保留多部分边界和块顺序。无序或并行写入可能会损坏流并导致错误。

- 使用 `io.Pipe` 流式传输多部分/表单数据：
	- __代码0__； __代码1__；使用 `pr` 作为 HTTP 请求正文
	- 将 `Content-Type` 设置为 `mw.FormDataContentType()`
	- 在 goroutine 中：按照正确的顺序将所有部分写入 `mw` ；出现错误 `pw.CloseWithError(err)`；成功后 `mw.Close()` 然后 `pw.Close()`
	- 不要在长期存在的客户端上存储请求/正在进行的表单状态；每次调用构建
	- 流媒体正文不可倒带；对于重试/重定向，缓冲小有效负载或提供 `GetBody`

### 分析

- 使用内置分析工具 (`pprof`)
- 对关键代码路径进行基准测试
- 优化前的配置文件
- 首先关注算法改进
- 考虑使用 `testing.B` 进行基准测试

## 测试

### 测试组织

- 将测试放在同一个包中（白盒测试）
- 使用`_test`包后缀进行黑盒测试
- 使用 `_test.go` 后缀命名测试文件
- 将测试文件放在他们测试的代码旁边

### 编写测试

- 对多个测试用例使用表驱动测试
- 使用 `Test_functionName_scenario` 描述性地命名测试
- 将子测试与 `t.Run` 一起使用以更好地组织
- 测试成功和错误情况
- 当 `testify` 或类似的库增加价值时，请考虑使用它们，但不要使简单的测试过于复杂

### 测试助手

- 用 `t.Helper()` 标记辅助函数
- 为复杂的设置创建测试夹具
- 对测试和基准测试中使用的函数使用 `testing.TB` 接口
- 使用 `t.Cleanup()` 清理资源

## 安全最佳实践

### 输入验证

- 验证所有外部输入
- 使用强类型来防止无效状态
- 在 SQL 查询中使用数据之前先清理数据
- 小心用户输入的文件路径
- 验证和转义不同上下文（HTML、SQL、shell）的数据

### 密码学

- 使用标准库加密包
- 不要实现自己的加密技术
- 使用 crypto/rand 生成随机数
- 使用 bcrypt、scrypt 或 argon2 存储密码（请考虑 golang.org/x/crypto 以获取其他选项）
- 使用 TLS 进行网络通信

## 文档

### 代码文档

- 通过清晰的命名和结构优先考虑自记录代码
- 记录所有导出的符号并提供清晰、简洁的解释
- 以符号名称开始文档
- 默认使用英文编写文档
- 如有帮助，请使用文档中的示例
- 让文档靠近代码
- 代码更改时更新文档
- 避免在文档和评论中使用表情符号

### 自述文件和文档文件

- 包括清晰的设置说明
- 记录依赖性和要求
- 提供使用示例
- 文档配置选项
- 包括故障排除部分

## 工具和开发工作流程

### 必备工具

- `go fmt`：格式代码
- `go vet`：查找可疑结构
- `golangci-lint`：额外的 linting（golint 已弃用）
- `go test`：运行测试
- `go mod`：管理依赖关系
- `go generate`：代码生成

### 开发实践

- 在提交之前运行测试
- 使用预提交挂钩进行格式化和 linting
- 保持提交的重点和原子性
- 编写有意义的提交消息
- 提交前检查差异

## 要避免的常见陷阱

- 不检查错误
- 忽略竞争条件
- 创建 goroutine 泄漏
- 不使用 defer 进行清理
- 同时修改地图
- 不理解 nil 接口与 nil 指针
- 忘记关闭资源（文件、连接）
- 不必要地使用全局变量
- 过度使用不受约束的类型（例如 `any`）；更喜欢带有约束的特定类型或泛型类型参数。如果需要不受约束的类型，请使用 `any` 而不是 `interface{}`
- 不考虑类型的零值
- **创建重复的 `package` 声明** - 这是一个编译错误；在添加包声明之前始终检查现有文件

---
description: "编写 Dart 和 Flutter 代码的官方推荐实践指令。"
applyTo: "**/*.dart"
---

# Dart 与 Flutter

Dart 和 Flutter 团队推荐的最佳实践。内容参考自 [Effective Dart](https://dart.dev/effective-dart) 和 [架构推荐](https://docs.flutter.dev/app-architecture/recommendations)。

## Effective Dart

多年来，我们编写了大量 Dart 代码，总结了哪些做法有效、哪些不推荐。我们分享这些经验，帮助你写出一致、健壮、高效的代码。两大主题：

1.  **保持一致。** 格式、命名等主观争议无解，但*一致性*客观有益。代码风格不同应有实质差异。引人注目的代码应有实际意义。
2.  **简洁明了。** Dart 设计上追求熟悉感，继承了 C、Java、JavaScript 等语法，但也有许多简化表达意图的新特性。多种写法时，优先选最简洁的。不是要“高尔夫代码”，而是*经济*，非*密集*。

### 主题分类

- **风格**：代码布局与组织规则，含标识符格式（`camelCase`、`using_underscores` 等）
- **文档**：注释、文档注释的写法
- **用法**：如何用语言特性实现行为
- **设计**：API 设计一致性与可用性经验

### 阅读方式

每个主题分为若干小节，每条规范以如下词开头：

- **DO**：必须遵循
- **DON'T**：几乎不应做
- **PREFER**：推荐，特殊情况可例外
- **AVOID**：不推荐，极少数情况可例外
- **CONSIDER**：可根据实际情况选择

部分规范有**例外**，需自行判断。

目标是可读、可维护的代码。

### 规范摘要

#### 风格

- 类型、扩展名用 `UpperCamelCase`
- 包、目录、文件、import 前缀用 `lowercase_with_underscores`
- 其他标识符用 `lowerCamelCase`
- 常量推荐 `lowerCamelCase`
- 缩写大于两字母按单词大写
- 未用回调参数推荐用通配符
- 非私有标识符勿用下划线前缀
- 勿用前缀字母
- 勿显式命名库
- `dart:` import 在前，`package:` 其次，最后相对路径
- export 单独分组，按字母排序
- 用 `dart format` 格式化
- 推荐 80 字符以内
- 所有流程控制语句用大括号

#### 文档

- 注释按句子格式
- 文档注释用 `///`
- 公共 API 推荐写文档注释
- 私有 API 可考虑写文档注释
- 文档注释首句单独成段
- 避免与上下文冗余
- 函数/方法副作用注释用第三人称动词开头
- 变量注释用名词短语
- 布尔变量注释用“Whether...”
- 库/类型注释用名词短语
- 可包含代码示例
- 用方括号引用作用域内标识符
- 用散文解释参数、返回值、异常
- 文档注释放在元数据注解前
- 避免过度 markdown/HTML
- 代码块用反引号围栏
- 推荐简洁，避免缩写
- 用“this”指代成员

#### 用法

- `part of` 指令用字符串
- 不 import 其他包 src 目录下库
- 不跨 lib 目录 import
- 推荐用相对路径 import
- 不显式初始化为 null
- 不用 null 作为默认值
- 不用 true/false 做等值判断
- 避免 late 变量需判断初始化
- 可用类型提升/null 检查
- 字符串拼接用相邻字符串或插值
- 避免插值中不必要的大括号
- 集合用字面量
- 判断空集合不用 .length
- 避免 Iterable.forEach + 匿名函数
- List.from 仅用于类型转换
- 用 whereType 过滤类型
- 避免用 cast
- 函数声明绑定函数名
- 能用 tear-off 不用 lambda
- 局部变量 var/final 规则一致
- 避免存储可计算值
- 不要无谓 getter/setter
- 只读属性用 final 字段
- 简单成员可用 =>
- this. 仅用于命名构造或避免遮蔽
- 字段能声明时初始化
- 构造用初始化参数
- 能用初始化列表不用 late
- 空构造体用 ;
- 不用 new/冗余 const
- 避免无 on 的 catch
- 不丢弃 catch 错误
- 仅程序性错误抛 Error
- 不 catch Error
- 用 rethrow 重新抛出异常
- 推荐 async/await
- 无实际效果勿用 async
- 可用高阶方法处理 stream
- 避免直接用 Completer
- 区分 Future<T> 时测试类型

#### 设计

- 术语一致，避免缩写
- 最具描述性的名词放最后
- 代码可读如句子
- 非布尔属性用名词短语
- 布尔属性用非命令动词短语
- 布尔参数可省略动词
- 布尔属性用正向命名
- 副作用函数用命令动词短语
- 返回值函数用名词/非命令动词短语
- 需强调工作量可用命令动词短语
- 方法名避免 get 开头
- 拷贝用 to...()，转换用 as...()
- 方法名避免描述参数
- 类型参数命名遵循惯例
- 推荐声明私有
- 可考虑同库多类
- 避免仅有一个成员的抽象类
- 避免全静态类
- 避免继承非为继承设计的类
- 用 class 修饰符控制可继承性
- 避免实现非接口类
- 用 class 修饰符控制可作为接口
- 推荐纯 mixin 或纯 class
- 构造器支持时可考虑 const
- 字段/顶级变量推荐 final
- 属性操作用 getter/setter
- setter 必须有 getter
- 避免用类型测试伪重载
- 避免无初始值的 public late final
- 避免返回可空 Future/Stream/集合
- 避免仅为链式返回 this
- 无初始值变量需类型注解
- 类型不明显字段/顶级变量需注解
- 已初始化局部变量勿冗余注解
- 函数声明需注解返回/参数类型
- 函数表达式参数类型勿冗余注解
- 初始化参数勿注解类型
- 泛型未推断时需写类型参数
- 已推断时勿写类型参数
- 避免不完整泛型
- 推断失败时用 dynamic
- 推荐函数类型注解
- setter 不指定返回类型
- 不用旧 typedef 语法
- 推荐内联函数类型
- 参数用函数类型语法
- 避免用 dynamic 禁用静态检查
- 无返回值异步成员用 Future<void>
- 避免用 FutureOr<T> 作为返回类型
- 避免位置布尔参数
- 避免可选位置参数导致省略前参
- 避免必须参数用特殊“无参”值
- 接受区间参数用闭区间起点、开区间终点
- 重写 == 必须重写 hashCode
- == 遵循数学等价规则
- 可变类避免自定义等价
- == 参数不可为 null

---

## Flutter 架构推荐

本页介绍架构最佳实践、重要性及适用场景。应根据实际需求灵活采纳。

- **强烈推荐**：新项目务必采用，老项目如无根本冲突也应考虑重构
- **推荐**：大概率提升质量
- **条件推荐**：特定场景下有益

### 关注点分离

- 明确数据层与 UI 层，层内按职责细分
- **强烈推荐**：数据层暴露数据并承载业务逻辑，UI 层负责展示和事件监听，UI 逻辑与组件分离
- **强烈推荐**：数据层用仓储模式（Repository），业务逻辑与数据访问解耦
- **强烈推荐**：UI 层用 ViewModel + View（MVVM），组件保持“哑”
- **条件推荐**：用 ChangeNotifier/Listenables 管理组件更新
- **强烈推荐**：组件不写业务逻辑，仅简单判断、动画、布局、路由
- **条件推荐**：复杂逻辑可加领域层（Domain Layer）

### 数据处理

- **强烈推荐**：单向数据流，数据只从数据层流向 UI 层
- **推荐**：用 Command 处理 UI 事件
- **强烈推荐**：数据模型不可变，变更需新实例，防止 UI 层误改
- **推荐**：用 freezed 或 built_value 生成不可变模型
- **条件推荐**：大型应用可区分 API 模型与领域模型

### 应用结构

- **强烈推荐**：依赖注入，推荐 provider 包
- **推荐**：导航用 go_router
- **推荐**：类、文件、目录命名规范，避免与 Flutter SDK 混淆
- **强烈推荐**：仓储类抽象，便于多实现和环境切换

### 测试

- **强烈推荐**：架构组件分别和整体测试，服务、仓储、ViewModel 单元测试，View 组件测试路由和依赖注入
- **强烈推荐**：为测试编写 fake，促使代码模块化、输入输出清晰

---

**免责声明**：本文档由[GitHub Copilot](https://docs.github.com/copilot/about-github-copilot/what-is-github-copilot)本地化。因此，可能包含错误。如果您发现任何不适当的翻译或错误，请创建一个[议题](../../issues)。

---
description: "遵循 Go 语言惯用法和社区标准的编程规范说明"
applyTo: "**/*.go,**/go.mod,**/go.sum"
---

# Go 开发规范

编写 Go 代码时请遵循惯用法和社区标准。以下内容参考自 [Effective Go](https://go.dev/doc/effective_go)、[Go Code Review Comments](https://go.dev/wiki/CodeReviewComments) 及 [Google Go Style Guide](https://google.github.io/styleguide/go/)。

## 通用规范

- 编写简洁、清晰、惯用的 Go 代码
- 优先考虑可读性和简单性，避免炫技
- 遵循“最小惊讶原则”
- 主流程左对齐（减少缩进）
- 尽早返回，减少嵌套
- 让零值有意义
- 为导出类型、函数、方法和包编写文档
- 使用 Go modules 进行依赖管理

## 命名规范

### 包

- 包名用小写单词，单词间不加下划线、连字符或混合大小写
- 包名应描述“提供什么”，而非“包含什么”
- 避免通用名如 util、common、base
- 包名用单数

### 变量与函数

- 用 mixedCaps 或 MixedCaps（驼峰），不用下划线
- 名字简短但具描述性
- 单字母变量仅用于极短作用域（如循环索引）
- 导出名首字母大写，未导出名小写
- 避免冗余前缀（如 http.HTTPServer，推荐 http.Server）

### 接口

- 尽量用 -er 结尾（如 Reader、Writer、Formatter）
- 单方法接口用方法名派生（如 Read → Reader）
- 接口应小而专注

### 常量

- 导出常量用 MixedCaps，未导出用 mixedCaps
- 相关常量用 const 分组
- 推荐用类型化常量提升类型安全

## 代码风格与格式化

### 格式化

- 始终用 gofmt 格式化代码
- 用 goimports 自动管理 import
- 行长适中，注重可读性
- 用空行分隔逻辑块

### 注释

- 注释用完整句子
- 以被描述对象名开头
- 包注释以“Package [name]”开头
- 多用行注释（//），块注释（/\* \*/）仅用于包文档
- 注重“为什么”，除非“做什么”很复杂

### 错误处理

- 函数调用后立即检查错误
- 除非有充分理由（需注释），不要用 \_ 忽略错误
- 用 fmt.Errorf 的 %w 包装错误
- 需区分错误时自定义错误类型
- 错误返回值放最后，变量名用 err
- 错误信息小写且不加标点

## 架构与项目结构

### 包组织

- 遵循标准 Go 项目布局
- 主程序放 cmd/ 目录
- 可复用包放 pkg/ 或 internal/
- internal/ 下的包仅限本项目引用
- 相关功能归组为包，避免循环依赖

### 依赖管理

- 用 Go modules（go.mod/go.sum）
- 依赖尽量精简
- 定期更新依赖以修复安全漏洞
- 用 go mod tidy 清理无用依赖
- 仅在必要时 vendor 依赖

## 类型安全与语言特性

### 类型定义

- 定义类型以增强语义和类型安全
- 结构体标签用于 JSON、XML、数据库映射
- 优先显式类型转换
- 类型断言需检查第二返回值

### 指针与值

- 大结构体或需修改接收者时用指针
- 小结构体或需不可变时用值
- 同一类型方法集内保持一致
- 选择指针/值接收者时考虑零值

### 接口与组合

- 参数用接口，返回具体类型
- 接口应小（1-3 方法为宜）
- 用嵌入实现组合
- 接口定义应靠近使用处
- 非必要不导出接口

## 并发

### 协程（Goroutine）

- 库中不主动创建协程，由调用方控制并发
- 明确协程退出方式
- 用 sync.WaitGroup 或 channel 等待协程
- 防止协程泄漏，确保清理

### 通道（Channel）

- 用 channel 实现协程间通信
- 不要通过共享内存通信，应通过通信共享内存
- 仅发送方关闭 channel
- 已知容量时用缓冲 channel
- 用 select 实现非阻塞操作

### 同步

- 用 sync.Mutex 保护共享状态
- 临界区尽量小
- 多读场景用 sync.RWMutex
- 能用 channel 就不用锁
- 用 sync.Once 实现一次性初始化

## 错误处理模式

### 创建错误

- 简单静态错误用 errors.New
- 动态错误用 fmt.Errorf
- 需区分时自定义错误类型
- 导出错误变量用于哨兵错误
- 用 errors.Is / errors.As 检查错误

### 错误传递

- 向上传递错误时补充上下文
- 不要既 log 又 return 错误（二选一）
- 在合适层级处理错误
- 复杂场景可用结构化错误

## API 设计

### HTTP 处理器

- 简单处理器用 http.HandlerFunc
- 需状态时实现 http.Handler
- 横切关注点用中间件
- 设置合适状态码和响应头
- 错误处理要优雅，返回合适响应

### JSON API

- 用结构体标签控制 JSON 序列化
- 校验输入数据
- 可选字段用指针
- 复杂场景可用 json.RawMessage 延迟解析
- 正确处理 JSON 错误

## 性能优化

### 内存管理

- 热路径尽量减少分配
- 能复用对象就复用（如 sync.Pool）
- 小结构体用值接收者
- 已知长度的切片预分配
- 避免不必要的字符串转换

### 性能分析

- 用内置 pprof 工具分析
- 关键路径做基准测试
- 优化前先分析
- 优先算法优化
- 用 testing.B 做基准测试

## 测试

### 测试组织

- 白盒测试与被测代码同包
- 黑盒测试用 \_test 包后缀
- 测试文件以 \_test.go 结尾
- 测试文件与被测代码同目录

### 编写测试

- 多用表驱动测试
- 测试函数命名用 Test*函数名*场景
- 用 t.Run 组织子测试
- 覆盖成功与失败场景
- 谨慎使用 testify 等三方库

### 测试辅助

- 辅助函数加 t.Helper()
- 复杂场景用测试夹具
- 测试/基准用 testing.TB 接口
- 用 t.Cleanup() 清理资源

## 安全最佳实践

### 输入校验

- 校验所有外部输入
- 强类型防止非法状态
- SQL 查询前清理数据
- 用户输入的文件路径需谨慎
- 针对不同场景（HTML、SQL、shell）校验和转义

### 加密

- 只用标准库加密包
- 不要自造加密算法
- 随机数用 crypto/rand
- 密码用 bcrypt 等存储
- 网络通信用 TLS

## 文档

### 代码文档

- 所有导出符号需文档
- 文档以符号名开头
- 必要时加示例
- 文档紧邻代码
- 代码变更时同步更新文档

### README 与文档文件

- 提供清晰的安装说明
- 记录依赖和要求
- 提供用例
- 说明配置项
- 包含故障排查

## 工具与开发流程

### 常用工具

- go fmt：格式化代码
- go vet：静态检查
- golint/golangci-lint：额外 lint
- go test：运行测试
- go mod：依赖管理
- go generate：代码生成

### 开发实践

- 提交前先跑测试
- 用 pre-commit 钩子自动格式化和 lint
- 保持原子性提交
- 编写有意义的提交信息
- 提交前审查 diff

## 常见陷阱

- 未检查错误
- 忽略竞态条件
- 协程泄漏
- 未用 defer 清理
- 并发修改 map
- 不理解 nil 接口与 nil 指针
- 忘记关闭资源（文件、连接）
- 不必要用全局变量
- 滥用空接口（interface{}）
- 忽略类型零值

---

> 本文档为自动翻译，仅供参考。如有歧义请以英文原文为准。

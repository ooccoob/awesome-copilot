---
description: '全面的技术无关提示，用于分析和记录项目文件夹结构。自动检测项目类型（.NET、Java、React、Angular、Python、Node.js、Flutter），生成带有可视化选项、命名约定、文件放置模式和扩展模板的详细蓝图，以在多样化技术堆栈中保持一致的代码组织。'
mode: 'agent'
---

# 项目文件夹结构蓝图生成器

## 配置变量

${PROJECT_TYPE="自动检测|.NET|Java|React|Angular|Python|Node.js|Flutter|其他"}
<!-- 选择主要技术 -->

${INCLUDES_MICROSERVICES="自动检测|true|false"}
<!-- 这是微服务架构吗？ -->

${INCLUDES_FRONTEND="自动检测|true|false"}
<!-- 项目是否包含前端组件？ -->

${IS_MONOREPO="自动检测|true|false"}
<!-- 这是包含多个项目的单一代码库吗？ -->

${VISUALIZATION_STYLE="ASCII|Markdown列表|表格"}
<!-- 如何可视化结构 -->

${DEPTH_LEVEL=1-5}
<!-- 详细记录多少级文件夹 -->

${INCLUDE_FILE_COUNTS=true|false}
<!-- 包含文件计数统计 -->

${INCLUDE_GENERATED_FOLDERS=true|false}
<!-- 包含自动生成的文件夹 -->

${INCLUDE_FILE_PATTERNS=true|false}
<!-- 记录文件命名/位置模式 -->

${INCLUDE_TEMPLATES=true|false}
<!-- 包含新功能的文件/文件夹模板 -->

## 生成的提示

"分析项目的文件夹结构并创建一个全面的'Project_Folders_Structure_Blueprint.md'文档，作为维护一致代码组织的明确指南。使用以下方法：

### 初始自动检测阶段

${PROJECT_TYPE == "自动检测" ?
"通过扫描文件夹结构中识别项目类型的关键文件开始：
- 查找解决方案/项目文件（.sln、.csproj、.fsproj、.vbproj）以识别.NET项目
- 检查构建文件（pom.xml、build.gradle、settings.gradle）用于Java项目
- 识别带有依赖的package.json用于JavaScript/TypeScript项目
- 查找特定框架文件（angular.json、react-scripts条目、next.config.js）
- 检查Python项目标识符（requirements.txt、setup.py、pyproject.toml）
- 检查移动应用标识符（pubspec.yaml、android/ios文件夹）
- 注意找到的所有技术签名及其版本" :
"专注于${PROJECT_TYPE}项目结构"}

${IS_MONOREPO == "自动检测" ?
"通过查找以下内容确定这是否是单一代码库：
- 具有自己配置文件的多个不同项目
- 工作区配置文件（lerna.json、nx.json、turborepo.json等）
- 跨项目引用和共享依赖模式
- 根级编排脚本和配置" : ""}

${INCLUDES_MICROSERVICES == "自动检测" ?
"检查微服务架构指标：
- 具有相似/重复结构的多个服务目录
- 特定于服务的Dockerfile或部署配置
- 服务间通信模式（API、消息代理）
- 服务注册或发现配置
- API网关配置文件
- 跨服务的共享库或实用程序" : ""}

${INCLUDES_FRONTEND == "自动检测" ?
"通过查找以下内容识别前端组件：
- Web资源目录（wwwroot、public、dist、static）
- UI框架文件（组件、模块、页面）
- 前端构建配置（webpack、vite、rollup等）
- 样式表组织（CSS、SCSS、styled-components）
- 静态资源组织（图像、字体、图标）" : ""}

### 1. 结构概览

提供${PROJECT_TYPE == "自动检测" ? "检测到的项目类型" : PROJECT_TYPE}项目组织原则和文件夹结构的高级概览：

- 记录文件夹结构反映的整体架构方法
- 识别主要的组织原则（按功能、按层、按域等）
- 注意整个代码库中重复的任何结构模式
- 在可以推断的地方记录结构的基本原理

${IS_MONOREPO == "自动检测" ?
"如果检测为单一代码库，解释单一代码库如何组织以及项目间的关系。" :
IS_MONOREPO ? "解释单一代码库如何组织以及项目间的关系。" : ""}

${INCLUDES_MICROSERVICES == "自动检测" ?
"如果检测到微服务，描述它们如何结构和组织。" :
INCLUDES_MICROSERVICES ? "描述微服务如何结构和组织。" : ""}

### 2. 目录可视化

${VISUALIZATION_STYLE == "ASCII" ?
"创建文件夹层级的ASCII树表示，深度级别${DEPTH_LEVEL}。" : ""}

${VISUALIZATION_STYLE == "Markdown列表" ?
"使用嵌套markdown列表表示文件夹层级，深度级别${DEPTH_LEVEL}。" : ""}

${VISUALIZATION_STYLE == "表格" ?
"创建包含路径、目的、内容类型和约定列的表格。" : ""}

${INCLUDE_GENERATED_FOLDERS ?
"包括所有文件夹，包括生成的文件夹。" :
"排除自动生成的文件夹，如bin/、obj/、node_modules/等。"}

### 3. 关键目录分析

记录每个重要目录的目的、内容和模式：

${PROJECT_TYPE == "自动检测" ?
"对于每个检测到的技术，基于观察到的使用模式分析目录结构：" : ""}

${(PROJECT_TYPE == ".NET" || PROJECT_TYPE == "自动检测") ?
"#### .NET项目结构（如果检测到）

- **解决方案组织**：
  - 项目如何分组和关联
  - 解决方案文件夹组织模式
  - 多目标项目模式

- **项目组织**：
  - 内部文件夹结构模式
  - 源代码组织方法
  - 资源组织
  - 项目依赖和引用

- **域/功能组织**：
  - 业务域或功能如何分离
  - 域边界执行模式

- **层组织**：
  - 关注点分离（控制器、服务、存储库等）
  - 层交互和依赖模式

- **配置管理**：
  - 配置文件位置和目的
  - 环境特定配置
  - 密钥管理方法

- **测试项目组织**：
  - 测试项目结构和命名
  - 测试类别和组织
  - 测试数据和模拟位置" : ""}

${(PROJECT_TYPE == "React" || PROJECT_TYPE == "Angular" || PROJECT_TYPE == "自动检测") ?
"#### UI项目结构（如果检测到）

- **组件组织**：
  - 组件文件夹结构模式
  - 分组策略（按功能、类型等）
  - 共享vs.功能特定组件

- **状态管理**：
  - 状态相关文件组织
  - 全局状态的存储结构
  - 本地状态管理模式

- **路由组织**：
  - 路由定义位置
  - 页面/视图组件组织
  - 路由参数处理

- **API集成**：
  - API客户端组织
  - 服务层结构
  - 数据获取模式

- **资源管理**：
  - 静态资源组织
  - 图像/媒体文件结构
  - 字体和图标组织

- **样式组织**：
  - CSS/SCSS文件结构
  - 主题组织
  - 样式模块模式" : ""}

### 4. 文件放置模式

${INCLUDE_FILE_PATTERNS ?
"记录确定不同类型文件应放置位置的模式：

- **配置文件**：
  - 不同类型配置的位置
  - 环境特定配置模式

- **模型/实体定义**：
  - 域模型定义的位置
  - 数据传输对象（DTO）位置
  - 模式定义位置

- **业务逻辑**：
  - 服务实现位置
  - 业务规则组织
  - 实用程序和辅助函数放置

- **接口定义**：
  - 接口和抽象定义的位置
  - 接口如何分组和组织

- **测试文件**：
  - 单元测试位置模式
  - 集成测试放置
  - 测试实用程序和模拟位置

- **文档文件**：
  - API文档放置
  - 内部文档组织
  - README文件分布" :
"记录项目中关键文件类型的位置。"}

### 5. 命名和组织约定

记录项目中观察到的命名和组织约定：

- **文件命名模式**：
  - 大小写约定（PascalCase、camelCase、kebab-case）
  - 前缀和后缀模式
  - 文件名中的类型指示器

- **文件夹命名模式**：
  - 不同文件夹类型的命名约定
  - 层次命名模式
  - 分组和分类约定

- **命名空间/模块模式**：
  - 命名空间/模块如何映射到文件夹结构
  - 导入/using语句组织
  - 内部vs.公共API分离

- **组织模式**：
  - 代码并置策略
  - 功能封装方法
  - 横切关注点组织

### 6. 导航和开发工作流

提供导航和使用代码库结构的指导：

- **入口点**：
  - 主应用程序入口点
  - 关键配置起点
  - 理解项目的初始文件

- **常见开发任务**：
  - 添加新功能的位置
  - 如何扩展现有功能
  - 放置新测试的位置
  - 配置修改位置

- **依赖模式**：
  - 依赖如何在文件夹间流动
  - 导入/引用模式
  - 依赖注入注册位置

${INCLUDE_FILE_COUNTS ?
"- **内容统计**：
  - 每个目录的文件分析
  - 代码分布指标
  - 复杂性集中区域" : ""}

### 7. 构建和输出组织
记录构建过程和输出组织：

- **构建配置**：
  - 构建脚本位置和目的
  - 构建管道组织
  - 构建任务定义

- **输出结构**：
  - 编译/构建输出位置
  - 输出组织模式
  - 分发包结构

- **环境特定构建**：
  - 开发vs.生产差异
  - 环境配置策略
  - 构建变体组织

### 8. 技术特定组织

${(PROJECT_TYPE == ".NET" || PROJECT_TYPE == "自动检测") ?
"#### .NET特定结构模式（如果检测到）

- **项目文件组织**：
  - 项目文件结构和模式
  - 目标框架配置
  - 属性组组织
  - 项组模式

- **程序集组织**：
  - 程序集命名模式
  - 多程序集架构
  - 程序集引用模式

- **资源组织**：
  - 嵌入资源模式
  - 本地化文件结构
  - 静态Web资源组织

- **包管理**：
  - NuGet配置位置
  - 包引用组织
  - 包版本管理" : ""}

${(PROJECT_TYPE == "Java" || PROJECT_TYPE == "自动检测") ?
"#### Java特定结构模式（如果检测到）

- **包层次结构**：
  - 包命名和嵌套约定
  - 域vs.技术包
  - 可见性和访问模式

- **构建工具组织**：
  - Maven/Gradle结构模式
  - 模块组织
  - 插件配置模式

- **资源组织**：
  - 资源文件夹结构
  - 环境特定资源
  - 属性文件组织" : ""}

${(PROJECT_TYPE == "Node.js" || PROJECT_TYPE == "自动检测") ?
"#### Node.js特定结构模式（如果检测到）

- **模块组织**：
  - CommonJS vs. ESM组织
  - 内部模块模式
  - 第三方依赖管理

- **脚本组织**：
  - npm/yarn脚本定义模式
  - 实用程序脚本位置
  - 开发工具脚本

- **配置管理**：
  - 配置文件位置
  - 环境变量管理
  - 密钥管理方法" : ""}

### 9. 扩展和演进
记录项目结构如何设计为可扩展：

- **扩展点**：
  - 如何在保持约定同时添加新模块/功能
  - 插件/扩展文件夹模式
  - 自定义目录结构

- **可扩展性模式**：
  - 结构如何为更大功能扩展
  - 分解大型模块的方法
  - 代码拆分策略

- **重构模式**：
  - 观察到的常见重构方法
  - 如何管理结构变更
  - 增量重组模式

${INCLUDE_TEMPLATES ?
"### 10. 结构模板

提供创建遵循项目约定的新组件的模板：

- **新功能模板**：
  - 添加完整功能的文件夹结构
  - 必需文件类型及其位置
  - 要遵循的命名模式

- **新组件模板**：
  - 典型组件的目录结构
  - 要包含的基本文件
  - 与现有结构的集成点

- **新服务模板**：
  - 添加新服务的结构
  - 接口和实现放置
  - 配置和注册模式

- **新测试结构**：
  - 测试项目/文件的文件夹结构
  - 测试文件组织模板
  - 测试资源组织" : ""}

### ${INCLUDE_TEMPLATES ? "11" : "10"}. 结构执行

记录项目结构如何维护和执行：

- **结构验证**：
  - 执行结构的工具/脚本
  - 结构合规性的构建检查
  - 与结构相关的代码检查规则

- **文档实践**：
  - 如何记录结构变更
  - 架构决策记录位置
  - 结构演进历史

在末尾包含一个关于维护此蓝图以及它最后更新时间的部分。
"
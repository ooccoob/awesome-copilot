---
description: '技术无关的蓝图生成器，用于创建全面的copilot-instructions.md文件，通过分析现有代码库模式并避免假设，指导GitHub Copilot生成符合项目标准、架构模式和精确技术版本的代码。'
mode: 'agent'
---

# Copilot 指令蓝图生成器

## 配置变量
${PROJECT_TYPE="自动检测|.NET|Java|JavaScript|TypeScript|React|Angular|Python|多个|其他"} <!-- 主要技术 -->
${ARCHITECTURE_STYLE="分层|微服务|单体|领域驱动|事件驱动|无服务器|混合"} <!-- 架构方法 -->
${CODE_QUALITY_FOCUS="可维护性|性能|安全性|可访问性|可测试性|全部"} <!-- 质量优先级 -->
${DOCUMENTATION_LEVEL="最小|标准|全面"} <!-- 文档需求 -->
${TESTING_REQUIREMENTS="单元|集成|端到端|TDD|BDD|全部"} <!-- 测试方法 -->
${VERSIONING="语义|CalVer|自定义"} <!-- 版本控制方法 -->

## 生成的提示

"生成一个全面的copilot-instructions.md文件，将指导GitHub Copilot生成符合我们项目标准、架构和技术版本的代码。指令必须严格基于我们代码库中的实际代码模式，避免做出任何假设。遵循此方法：

### 1. 核心指令结构

```markdown
# GitHub Copilot 指令

## 优先级指导原则

为此仓库生成代码时：

1. **版本兼容性**：始终检测并尊重此项目中使用的语言、框架和库的确切版本
2. **上下文文件**：优先考虑.github/copilot目录中定义的模式和标准
3. **代码库模式**：当上下文文件没有提供具体指导时，扫描代码库寻找已建立的模式
4. **架构一致性**：保持我们的${ARCHITECTURE_STYLE}架构风格和已建立的边界
5. **代码质量**：在所有生成的代码中优先考虑${CODE_QUALITY_FOCUS == "全部" ? "可维护性、性能、安全性、可访问性和可测试性" : CODE_QUALITY_FOCUS}

## 技术版本检测

在生成代码之前，扫描代码库以识别：

1. **语言版本**：检测使用中的编程语言的准确版本
   - 检查项目文件、配置文件和包管理器
   - 查找特定语言的版本指示器（例如，.NET项目中的<LangVersion>）
   - 永远不要使用超出检测版本的的语言功能

2. **框架版本**：识别所有框架的准确版本
   - 检查package.json、.csproj、pom.xml、requirements.txt等
   - 生成代码时尊重版本约束
   - 永远不要建议在检测的框架版本中不可用的功能

3. **库版本**：注意关键库和依赖项的准确版本
   - 生成与这些特定版本兼容的代码
   - 永远不要使用在检测版本中不可用的API或功能

## 上下文文件

优先考虑.github/copilot目录中的以下文件（如果存在）：

- **architecture.md**：系统架构指导原则
- **tech-stack.md**：技术版本和框架详细信息
- **coding-standards.md**：代码样式和格式化标准
- **folder-structure.md**：项目组织指导原则
- **exemplars.md**：要遵循的示例代码模式

## 代码库扫描指令

当上下文文件没有提供具体指导时：

1. 识别与正在修改或创建的文件类似的文件
2. 分析以下方面的模式：
   - 命名约定
   - 代码组织
   - 错误处理
   - 日志方法
   - 文档样式
   - 测试模式

3. 遵循代码库中发现的最一致的模式
4. 当存在冲突的模式时，优先考虑较新文件或具有较高测试覆盖率的文件中的模式
5. 永远不要引入现有代码库中不存在的模式

## 代码质量标准

${CODE_QUALITY_FOCUS.includes("可维护性") || CODE_QUALITY_FOCUS == "全部" ? `### 可维护性
- 编写具有清晰命名的自文档化代码
- 遵循代码库中明显的命名和组织约定
- 遵循已建立的模式以保持一致性
- 保持函数专注于单一职责
- 限制函数复杂性和长度以匹配现有模式` : ""}

${CODE_QUALITY_FOCUS.includes("性能") || CODE_QUALITY_FOCUS == "全部" ? `### 性能
- 遵循现有的内存和资源管理模式
- 匹配处理计算昂贵操作的现有模式
- 遵循已建立的异步操作模式
- 根据现有模式一致地应用缓存
- 根据代码库中明显的模式进行优化` : ""}

${CODE_QUALITY_FOCUS.includes("安全性") || CODE_QUALITY_FOCUS == "全部" ? `### 安全性
- 遵循现有的输入验证模式
- 应用代码库中使用的相同清理技术
- 使用与现有模式匹配的参数化查询
- 遵循已建立的身份验证和授权模式
- 根据现有模式处理敏感数据` : ""}

${CODE_QUALITY_FOCUS.includes("可访问性") || CODE_QUALITY_FOCUS == "全部" ? `### 可访问性
- 遵循代码库中现有的可访问性模式
- 将ARIA属性使用与现有组件匹配
- 保持与现有代码一致的键盘导航支持
- 遵循颜色和对比度的已建立模式
- 应用与代码库一致的文本替代模式` : ""}

${CODE_QUALITY_FOCUS.includes("可测试性") || CODE_QUALITY_FOCUS == "全部" ? `### 可测试性
- 遵循可测试代码的已建立模式
- 匹配代码库中使用的依赖注入方法
- 应用相同的管理依赖项模式
- 遵循已建立的模拟和测试双重模式
- 匹配现有测试中使用的测试样式` : ""}

## 文档需求

${DOCUMENTATION_LEVEL == "最小" ?
`- 匹配现有代码中发现的注释级别和样式
- 根据代码库中观察到的模式进行文档化
- 遵循记录非明显行为的现有模式
- 使用与现有代码相同的参数描述格式` : ""}

${DOCUMENTATION_LEVEL == "标准" ?
`- 遵循代码库中发现的确切文档格式
- 匹配现有注释的XML/JSDoc样式和完整性
- 以相同的样式文档化参数、返回值和异常
- 遵循使用示例的现有模式
- 匹配类级别文档样式和内容` : ""}

${DOCUMENTATION_LEVEL == "全面" ?
`- 遵循代码库中发现的最详细文档模式
- 匹配最佳文档代码的样式和完整性
- 完全像最彻底文档化的文件那样进行文档化
- 遵循链接文档的现有模式
- 匹配设计决策解释中的详细程度` : ""}

## 测试方法

${TESTING_REQUIREMENTS.includes("单元") || TESTING_REQUIREMENTS == "全部" ?
`### 单元测试
- 匹配现有单元测试的确切结构和样式
- 遵循测试类和方法命名的相同约定
- 使用现有测试中发现的相同断言模式
- 应用代码库中使用的相同模拟方法
- 遵循测试隔离的现有模式` : ""}

${TESTING_REQUIREMENTS.includes("集成") || TESTING_REQUIREMENTS == "全部" ?
`### 集成测试
- 遵循代码库中发现的相同集成测试模式
- 匹配测试数据设置和清理的现有模式
- 使用测试组件交互的相同方法
- 遵循验证系统行为的现有模式` : ""}

${TESTING_REQUIREMENTS.includes("端到端") || TESTING_REQUIREMENTS == "全部" ?
`### 端到端测试
- 匹配现有端到端测试结构和模式
- 遵循已建立的UI测试模式
- 应用验证用户旅程的相同方法` : ""}

${TESTING_REQUIREMENTS.includes("TDD") || TESTING_REQUIREMENTS == "全部" ?
`### 测试驱动开发
- 遵循代码库中明显的TDD模式
- 匹配现有代码中看到的测试用例进展
- 在测试通过后应用相同的重构模式` : ""}

${TESTING_REQUIREMENTS.includes("BDD") || TESTING_REQUIREMENTS == "全部" ?
`### 行为驱动开发
- 匹配测试中现有的Given-When-Then结构
- 遵循行为描述的相同模式
- 在测试用例中应用相同的业务关注级别` : ""}

## 特定技术指导原则

${PROJECT_TYPE == ".NET" || PROJECT_TYPE == "自动检测" || PROJECT_TYPE == "多个" ? `### .NET 指导原则
- 检测并严格遵守使用中的特定.NET版本
- 仅使用与检测版本兼容的C#语言功能
- 完全按照代码库中出现的方式遵循LINQ使用模式
- 从现有代码匹配异步/等待使用模式
- 应用代码库中使用的相同依赖注入方法
- 使用现有代码中找到的相同集合类型和模式` : ""}

${PROJECT_TYPE == "Java" || PROJECT_TYPE == "自动检测" || PROJECT_TYPE == "多个" ? `### Java 指导原则
- 检测并遵守使用中的特定Java版本
- 完全遵循代码库中发现的相同设计模式
- 匹配现有代码中的异常处理模式
- 使用代码库中找到的相同集合类型和方法
- 应用现有代码中明显的依赖注入模式` : ""}

${PROJECT_TYPE == "JavaScript" || PROJECT_TYPE == "TypeScript" || PROJECT_TYPE == "自动检测" || PROJECT_TYPE == "多个" ? `### JavaScript/TypeScript 指导原则
- 检测并遵守使用中的特定ECMAScript/TypeScript版本
- 遵循代码库中发现的相同模块导入/导出模式
- 将TypeScript类型定义与现有模式匹配
- 使用与现有代码相同的异步模式（promises、async/await）
- 遵循类似文件中的错误处理模式` : ""}

${PROJECT_TYPE == "React" || PROJECT_TYPE == "自动检测" || PROJECT_TYPE == "多个" ? `### React 指导原则
- 检测并遵守使用中的特定React版本
- 匹配现有组件中的组件结构模式
- 遵循代码库中发现的相同hooks和生命周期模式
- 应用现有组件中使用的相同状态管理方法
- 匹配现有代码中的prop类型和验证模式` : ""}

${PROJECT_TYPE == "Angular" || PROJECT_TYPE == "自动检测" || PROJECT_TYPE == "多个" ? `### Angular 指导原则
- 检测并遵守使用中的特定Angular版本
- 遵循代码库中发现的相同组件和模块模式
- 完全按照现有代码中看到的方式匹配装饰器使用
- 应用代码库中发现的相同RxJS模式
- 遵循组件通信的现有模式` : ""}

${PROJECT_TYPE == "Python" || PROJECT_TYPE == "自动检测" || PROJECT_TYPE == "多个" ? `### Python 指导原则
- 检测并遵守使用中的特定Python版本
- 遵循现有模块中发现的相同导入组织
- 如果代码库中使用，匹配类型提示方法
- 应用现有代码中发现的相同错误处理模式
- 遵循相同的模块组织模式` : ""}

## 版本控制指导原则

${VERSIONING == "语义" ?
`- 遵循代码库中应用的语义版本控制模式
- 匹配记录破坏性更改的现有模式
- 遵循弃用通知的相同方法` : ""}

${VERSIONING == "CalVer" ?
`- 遵循代码库中应用的日历版本控制模式
- 匹配记录更改的现有模式
- 遵循突出显示重要更改的相同方法` : ""}

${VERSIONING == "自定义" ?
`- 匹配代码库中观察到的确切版本控制模式
- 遵循现有文档中使用的相同变更日志格式
- 应用项目中使用的相同标记约定` : ""}

## 通用最佳实践

- 完全按照现有代码中出现的方式遵循命名约定
- 匹配来自类似文件的代码组织模式
- 应用与现有模式一致的错误处理
- 遵循代码库中看到的相同测试方法
- 匹配现有代码中的日志模式
- 使用与代码库中看到的相同的配置方法

## 项目特定指导

- 在生成任何代码之前彻底扫描代码库
- 毫无例外地尊重现有架构边界
- 匹配周围代码的样式和模式
- 当有疑问时，优先考虑与现有代码的一致性，而不是外部最佳实践
```

### 2. 代码库分析指令

要创建copilot-instructions.md文件，首先分析代码库以：

1. **识别确切的技术版本**：
   - ${PROJECT_TYPE == "自动检测" ? "通过扫描文件扩展名和配置文件检测所有编程语言、框架和库" : `专注于${PROJECT_TYPE}技术`}
   - 从项目文件、package.json、.csproj等中提取精确版本信息
   - 记录版本约束和兼容性要求

2. **理解架构**：
   - 分析文件夹结构和模块组织
   - 识别清晰的层边界和组件关系
   - 记录组件间的通信模式

3. **文档化代码模式**：
   - 编目不同代码元素的命名约定
   - 注意文档样式和完整性
   - 文档化错误处理模式
   - 映射测试方法和覆盖率

4. **注意质量标准**：
   - 识别实际使用的性能优化技术
   - 记录代码中实施的安全实践
   - 注意存在的可访问性功能（如适用）
   - 记录代码库中明显的代码质量模式

### 3. 实施说明

最终的copilot-instructions.md应该：
- 放在.github/copilot目录中
- 仅引用代码库中存在的模式和标准
- 包括明确的版本兼容性要求
- 避免规定代码库中不明显的任何实践
- 提供来自代码库的具体示例
- 全面但足够简洁，以便Copilot有效使用

重要：仅包含基于代码库中实际观察到的模式的指导。明确指示Copilot优先考虑与现有代码的一致性，而不是外部最佳实践或更新的语言功能。
"

## 预期输出

一个全面的copilot-instructions.md文件，将指导GitHub Copilot生成与您现有技术版本完美兼容并遵循您已建立模式和架构的代码。
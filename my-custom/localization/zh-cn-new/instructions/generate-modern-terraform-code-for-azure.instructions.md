---
description: '为Azure生成现代Terraform代码的指南'
applyTo: '**/*.tf'
---

## 1. 使用最新的Terraform和提供商

始终以最新的稳定Terraform版本和Azure提供商为目标。在代码中，指定所需的Terraform和提供商版本以强制执行此操作。保持提供商版本更新以获得新功能和修复。

## 2. 清晰地组织代码

使用逻辑文件分离构建Terraform配置：

- 使用`main.tf`存放资源
- 使用`variables.tf`存放输入
- 使用`outputs.tf`存放输出
- 遵循一致的命名约定和格式（`terraform fmt`）

这使得代码易于导航和维护。

## 3. 封装到模块中

使用Terraform模块来分组可重用的基础架构组件。对于将在多个上下文中使用的任何资源集：

- 创建具有自己的变量/输出的模块
- 引用它而不是重复代码
- 这促进重用和一致性

## 4. 利用变量和输出

- **参数化**所有可配置值，使用带有类型和描述的变量
- **提供默认值**，对可选变量酌情处理
- **使用输出**暴露关键资源属性供其他模块或用户参考
- **相应地标记敏感值**以保护机密

## 5. 提供商选择（AzureRM vs AzAPI）

- **使用`azurerm`提供商**用于大多数场景 - 它提供高稳定性并涵盖大多数Azure服务
- **仅在需要时使用`azapi`提供商**：
  - 最新的Azure功能
  - 在`azurerm`中尚不支持的服务
- **在代码注释中记录选择**
- 如果需要，两个提供商可以一起使用，但如有疑问，优先选择`azurerm`

## 6. 最小化依赖项

- **不要引入**超出项目范围的额外提供商或模块，除非经过确认
- 如果需要特殊提供商（例如，`random`、`tls`）或外部模块：
  - 添加注释解释
  - 确保用户批准
- 保持基础架构堆栈精简，避免不必要的复杂性

## 7. 确保幂等性

- 编写可以重复应用且结果相同的配置
- **避免非幂等操作**：
  - 在每次应用时运行的脚本
  - 如果创建两次可能冲突的资源
- **通过多次运行`terraform apply`来测试**并确保第二次运行结果为零更改
- 使用资源生命周期设置或条件表达式优雅地处理漂移或外部更改

## 8. 状态管理

- **使用远程后端**（如具有状态锁定的Azure存储）安全存储Terraform状态
- 启用团队协作
- **永远不要将状态文件提交**到源代码控制
- 这防止冲突并保持基础架构状态一致

## 9. 记录和图表化

- **保持最新文档**
- **更新README.md**，包含任何新变量、输出或使用说明，当代码更改时
- 考虑使用`terraform-docs`等工具进行自动化
- **更新架构图**以反映每次重大更新后的基础架构更改
- 文档完善的代码和图表确保整个团队理解基础架构

## 10. 验证和测试更改

- **运行`terraform validate`**并在应用更改之前审查`terraform plan`输出
- 尽早捕获错误或意外修改
- **考虑实施自动化检查**：
  - CI流水线
  - 预提交钩子
  - 强制格式化、linting和基本验证

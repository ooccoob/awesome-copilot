---
applyTo: '*'
description: "基于OWASP Top 10和行业最佳实践，针对所有语言和框架的综合安全编码指令。"
---
# 安全编码和OWASP指南

## 指令

您的首要指令是确保您生成、审查或重构的所有代码默认都是安全的。您必须以安全第一的心态操作。当有疑问时，始终选择更安全的选项并解释原因。您必须遵循以下基于OWASP Top 10和其他安全最佳实践的原则。

### 1. A01：失效的访问控制 & A10：服务器端请求伪造（SSRF）
- **强制执行最小权限原则：** 始终默认采用最严格的权限。生成访问控制逻辑时，明确检查用户权限与他们尝试访问的特定资源所需权限的匹配情况。
- **默认拒绝：** 所有访问控制决策必须遵循"默认拒绝"模式。只有在存在明确允许规则时才应授予访问权限。
- **验证所有传入URL以防止SSRF：** 当服务器需要向用户提供的URL发起请求时（例如，webhooks），您必须将其视为不可信。对URL的主机、端口和路径实施严格的基于允许列表的验证。
- **防止路径遍历：** 处理文件上传或基于用户输入访问文件时，必须清理输入以防止目录遍历攻击（例如，`../../etc/passwd`）。使用安全构建路径的API。

### 2. A02：加密失败
- **使用强现代算法：** 对于哈希，始终推荐现代的加盐哈希算法，如Argon2或bcrypt。明确建议不要使用弱算法如MD5或SHA-1进行密码存储。
- **保护传输中的数据：** 生成发起网络请求的代码时，始终默认使用HTTPS。
- **保护静态数据：** 建议存储敏感数据（PII、令牌等）的代码时，推荐使用强标准算法如AES-256进行加密。
- **安全秘密管理：** 永远不要硬编码秘密（API密钥、密码、连接字符串）。生成从环境变量或秘密管理服务（例如，HashiCorp Vault、AWS Secrets Manager）读取秘密的代码。包含清晰的占位符和注释。
  ```javascript
  // 好：从环境或秘密存储加载
  const apiKey = process.env.API_KEY;
  // TODO：确保在您的环境中安全配置API_KEY。
  ```
  ```python
  // 坏：硬编码秘密
  api_key = "sk_this_is_a_very_bad_idea_12345"
  ```

### 3. A03：注入
- **不使用原始SQL查询：** 对于数据库交互，您必须使用参数化查询（准备语句）。永远不要生成使用字符串连接或格式化从用户输入构建查询的代码。
- **清理命令行输入：** 对于OS命令执行，使用内置函数处理参数转义并防止shell注入（例如，Python中的`shlex`）。
- **防止跨站脚本（XSS）：** 生成显示用户控制数据的前端代码时，您必须使用上下文感知的输出编码。优先使用默认将数据视为文本的方法（`.textContent`）而不是解析HTML的方法（`.innerHTML`）。当`innerHTML`必要时，建议首先使用像DOMPurify这样的库来清理HTML。

### 4. A05：安全配置错误 & A06：易受攻击的组件
- **安全默认配置：** 建议在生产环境中禁用详细错误消息和调试功能。
- **设置安全头：** 对于Web应用程序，建议添加基本安全头如`Content-Security-Policy`（CSP）、`Strict-Transport-Security`（HSTS）和`X-Content-Type-Options`。
- **使用最新依赖：** 当被要求添加新库时，建议使用最新的稳定版本。提醒用户运行漏洞扫描器如`npm audit`、`pip-audit`或Snyk来检查项目依赖中的已知漏洞。

### 5. A07：身份识别和身份验证失败
- **安全会话管理：** 用户登录时，生成新的会话标识符以防止会话固定。确保会话cookie配置了`HttpOnly`、`Secure`和`SameSite=Strict`属性。
- **防止暴力破解：** 对于身份验证和密码重置流程，建议在一定次数失败尝试后实施速率限制和账户锁定机制。

### 6. A08：软件和数据完整性失败
- **防止不安全的反序列化：** 警告不要在没有适当验证的情况下反序列化来自不受信任来源的数据。如果反序列化是必要的，建议使用不易受攻击的格式（如Python中的JSON而不是Pickle）并实施严格的类型检查。

## 一般指南
- **明确说明安全性：** 当您建议缓解安全风险的代码时，明确说明您在防范什么（例如，"这里使用参数化查询以防止SQL注入。"）。
- **在代码审查期间进行教育：** 当您在代码审查中发现安全漏洞时，您不仅要提供更正的代码，还要解释与原始模式相关的风险。
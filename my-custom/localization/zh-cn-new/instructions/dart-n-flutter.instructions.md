---
description: '编写Dart和Flutter代码的指导原则，遵循官方建议。'
applyTo: '**/*.dart'
---

# Dart 和 Flutter

Dart和Flutter团队推荐的最佳实践。这些指导原则取自[Effective Dart](https://dart.dev/effective-dart)和[Architecture Recommendations](https://docs.flutter.dev/app-architecture/recommendations)。

## Effective Dart

在过去的几年里，我们编写了大量的Dart代码，并学到了很多关于什么方法有效、什么方法无效的经验。我们与您分享这些经验，以便您也能编写一致、健壮、快速的代码。有两个总体的主题：

1.  **保持一致性。** 当涉及到格式化和大小写等问题时，关于哪个更好的争论是主观的，无法解决。我们确实知道的是，保持*一致性*是客观上有帮助的。

    如果两段代码看起来不同，那应该是因为它们在某个有意义的方面确实*不同*。当一段代码突出并吸引你的注意时，应该是因为有实用的原因。

2.  **保持简洁。** Dart被设计为熟悉的语言，因此它继承了许多与C、Java、JavaScript和其他语言相同的语句和表达式。但我们创建Dart是因为这些语言还有很多改进的空间。我们添加了许多功能，从字符串插值到初始化形式参数，帮助您更简单、更轻松地表达您的意图。

    如果有多种方式表达同一件事，通常应该选择最简洁的一种。这并不是说要您把自己压缩到单行程序中。目标是编写*简洁*的代码，而不是*密集*的代码。

### 主题分类

我们将指导原则分为几个独立的主题以便于理解：

*   **风格** – 这定义了布局和组织代码的规则，或者至少是`dart format`没有为您处理的部分。风格主题还指定了标识符的格式：`camelCase`、`using_underscores`等。

*   **文档** – 这告诉您需要了解的关于注释内容的一切。包括文档注释和普通的、日常的代码注释。

*   **使用** – 这教您如何最好地利用语言功能来实现行为。如果在语句或表达式中，这里会涵盖。

*   **设计** – 这是最软性的主题，但范围最广。它涵盖了我们在为库设计一致、可用的API方面的经验。如果在类型签名或声明中，这里会讨论。

### 如何阅读主题

每个主题分为几个部分。部分包含指导原则列表。每个指导原则以以下词语之一开始：

*   **DO** 指导原则描述了应该始终遵循的实践。几乎从来没有合理的理由偏离它们。

*   **DON'T** 指导原则是相反的：几乎从来都不是好主意的事情。希望我们没有其他语言那么多这样的指导原则，因为我们有更少的历史包袱。

*   **PREFER** 指导原则是您*应该*遵循的实践。但是，在某些情况下可能有意义地做其他事情。只要确保您在忽略指导原则时理解其全部含义。

*   **AVOID** 指导原则是"prefer"的对立面：您不应该做的事情，但在极少数情况下可能有充分的理由去做。

*   **CONSIDER** 指导原则是您可能或可能不想遵循的实践，取决于情况、先例和您自己的偏好。

一些指导原则描述了规则不适用的**例外**。当列出时，例外可能不全面——您可能仍需要在其他情况下使用您的判断。

这听起来好像如果您没有正确系好鞋带，警察就要砸您的门。事情没有那么糟糕。这里的大多数指导原则都是常识，我们都是理性的人。目标始终是编写好的、可读的和可维护的代码。

### 规则

#### 风格

##### 标识符

*   DO 使用`UpperCamelCase`命名类型。
*   DO 使用`UpperCamelCase`命名扩展。
*   DO 使用`lowercase_with_underscores`命名包、目录和源文件。
*   DO 使用`lowercase_with_underscores`命名导入前缀。
*   DO 使用`lowerCamelCase`命名其他标识符。
*   PREFER 使用`lowerCamelCase`命名常量名称。
*   DO 将长度超过两个字母的缩略语和缩写词像单词一样大写。
*   PREFER 对未使用的回调参数使用通配符。
*   DON'T 对非私有标识符使用前导下划线。
*   DON'T 使用前缀字母。
*   DON'T 显式命名库。

##### 排序

*   DO 将`dart:`导入放在其他导入之前。
*   DO 将`package:`导入放在相对导入之前。
*   DO 在所有导入之后的单独部分中指定导出。
*   DO 按字母顺序对部分进行排序。

##### 格式化

*   DO 使用`dart format`格式化您的代码。
*   CONSIDER 更改您的代码使其更友好于格式化程序。
*   PREFER 使用80个字符或更少的行。
*   DO 对所有流控制语句使用大括号。

#### 文档

##### 注释

*   DO 像句子一样格式化注释。
*   DON'T 对文档使用块注释。

##### 文档注释

*   DO 使用`///`文档注释来记录成员和类型。
*   PREFER 为公共API编写文档注释。
*   CONSIDER 编写库级别的文档注释。
*   CONSIDER 为私有API编写文档注释。
*   DO 用单句摘要开始文档注释。
*   DO 将文档注释的第一句话分成自己的段落。
*   AVOID 与周围上下文冗余。
*   PREFER 如果函数或方法的主要目的是副作用，用第三人称动词开始注释。
*   PREFER 对非布尔变量或属性用名词短语开始注释。
*   PREFER 对布尔变量或属性用"Whether"后跟名词或动名词短语开始注释。
*   PREFER 如果返回值是函数或方法的主要目的，用名词短语或非命令式动词短语。
*   DON'T 为属性的getter和setter都编写文档。
*   PREFER 用名词短语开始库或类型注释。
*   CONSIDER 在文档注释中包含代码示例。
*   DO 在文档注释中使用方括号引用范围内的标识符。
*   DO 用散文解释参数、返回值和异常。
*   DO 将文档注释放在元数据注释之前。

##### Markdown

*   AVOID 过度使用markdown。
*   AVOID 使用HTML进行格式化。
*   PREFER 对代码块使用反引号围栏。

##### 写作

*   PREFER 简洁。
*   AVOID 除非显而易见，否则避免使用缩写和缩略语。
*   PREFER 使用"this"而不是"the"来引用成员实例。

#### 使用

##### 库

*   DO 在`part of`指令中使用字符串。
*   DON'T 导入另一个包的`src`目录内的库。
*   DON'T 允许导入路径进入或离开`lib`。
*   PREFER 使用相对导入路径。

##### 空值

*   DON'T 显式地将变量初始化为`null`。
*   DON'T 使用`null`的显式默认值。
*   DON'T 在相等操作中使用`true`或`false`。
*   AVOID 如果您需要检查是否已初始化，不要使用`late`变量。
*   CONSIDER 对使用可空类型使用类型提升或空值检查模式。

##### 字符串

*   DO 使用相邻字符串来连接字符串字面量。
*   PREFER 使用插值来组合字符串和值。
*   AVOID 在不需要时在插值中使用大括号。

##### 集合

*   DO 尽可能使用集合字面量。
*   DON'T 使用`.length`来查看集合是否为空。
*   AVOID 将`Iterable.forEach()`与函数字面量一起使用。
*   DON`T 除非您打算更改结果的类型，否则使用`List.from()`。
*   DO 使用`whereType()`按类型过滤集合。
*   DON'T 当附近操作会做时使用`cast()`。
*   AVOID 使用`cast()`。

##### 函数

*   DO 使用函数声明将函数绑定到名称。
*   DON'T 当简写可以做到时创建lambda。

##### 变量

*   DO 对局部变量遵循一致的`var`和`final`规则。
*   AVOID 存储您可以计算的内容。

##### 成员

*   DON'T 不必要地将字段包装在getter和setter中。
*   PREFER 使用`final`字段来创建只读属性。
*   CONSIDER 对简单成员使用`=>`。
*   DON'T 使用`this.`，除非重定向到命名构造函数或避免遮蔽。
*   DO 尽可能在声明时初始化字段。

##### 构造函数

*   DO 尽可能使用初始化形式参数。
*   DON'T 当构造函数初始化列表可以做到时使用`late`。
*   DO 对空构造函数体使用`;`而不是`{}`。
*   DON'T 使用`new`。
*   DON'T 冗余地使用`const`。

##### 错误处理

*   AVOID 没有`on`子句的catch。
*   DON`T 丢弃没有`on`子句的catch中的错误。
*   DO 仅对程序错误抛出实现`Error`的对象。
*   DON`T 显式捕获`Error`或实现它的类型。
*   DO 使用`rethrow`重新抛出捕获的异常。

##### 异步

*   PREFER 异步/等待而不是使用原始Future。
*   DON`T 当它没有有用效果时使用`async`。
*   CONSIDER 使用高阶方法来转换流。
*   AVOID 直接使用Completer。
*   DO 在消除类型参数可能是`Object`的`FutureOr<T>`时测试`Future<T>`。

#### 设计

##### 名称

*   DO 一致地使用术语。
*   AVOID 缩写。
*   PREFER 将最具描述性的名词放在最后。
*   CONSIDER 让代码读起来像句子。
*   PREFER 对非布尔属性或变量使用名词短语。
*   PREFER 对布尔属性或变量使用非命令式动词短语。
*   CONSIDER 对命名布尔参数省略动词。
*   PREFER 对布尔属性或变量使用"肯定"名称。
*   PREFER 对主要目的是副作用的函数或方法使用命令式动词短语。
*   PREFER 如果返回值是主要目的，对函数或方法使用名词短语或非命令式动词短语。
*   CONSIDER 如果您想引起对其执行工作的注意，对函数或方法使用命令式动词短语。
*   AVOID 避免以`get`开始方法名。
*   PREFER 如果它将对象状态复制到新对象，将方法命名为`to...()`。
*   PREFER 如果它返回由原始对象支持的不同表示，将方法命名为`as...()`。
*   AVOID 避免在函数或方法名中描述参数。
*   DO 在命名类型参数时遵循现有的助记符约定。

##### 库

*   PREFER 将声明设为私有。
*   CONSIDER 在同一库中声明多个类。

##### 类和混入

*   AVOID 当简单函数可以做到时定义单成员抽象类。
*   AVOID 定义只包含静态成员的类。
*   AVOID 扩展不打算被子类化的类。
*   DO 使用类修饰符来控制您的类是否可以扩展。
*   AVOID 实现不打算作为接口的类。
*   DO 使用类修饰符来控制您的类是否可以是接口。
*   PREFER 定义纯`mixin`或纯`class`而不是`mixin class`。

##### 构造函数

*   CONSIDER 如果类支持，将您的构造函数设为`const`。

##### 成员

*   PREFER 将字段和顶级变量设为`final`。
*   DO 对概念上访问属性的操作使用getter。
*   DO 对概念上更改属性的操作使用setter。
*   DON`T 定义没有相应getter的setter。
*   AVOID 使用运行时类型测试来伪造重载。
*   AVOID 没有初始化器的公共`late final`字段。
*   AVOID 返回可空的`Future`、`Stream`和集合类型。
*   AVOID 从方法返回`this`只是为了启用流畅接口。

##### 类型

*   DO 对没有初始化器的变量进行类型注释。
*   DO 如果类型不明显，对字段和顶级变量进行类型注释。
*   DON`T 冗余地类型注释已初始化的局部变量。
*   DO 对函数声明注释返回类型。
*   DO 对函数声明注释参数类型。
*   DON`T 对函数表达式的推断参数类型进行类型注释。
*   DON`T 对初始化形式参数进行类型注释。
*   DO 对未推断的泛型调用编写类型参数。
*   DON`T 对已推断的泛型调用编写类型参数。
*   AVOID 编写不完整的泛型类型。
*   DO 使用`dynamic`进行注释而不是让推断失败。
*   PREFER 在函数类型注释中使用签名。
*   DON`T 为setter指定返回类型。
*   DON`T 使用传统的typedef语法。
*   PREFER 内联函数类型而不是typedef。
*   PREFER 对参数使用函数类型语法。
*   AVOID 除非您想禁用静态检查，否则使用`dynamic`。
*   DO 对不产生值的异步成员使用`Future<void>`作为返回类型。
*   AVOID 使用`FutureOr<T>`作为返回类型。

##### 参数

*   AVOID 位置布尔参数。
*   AVOID 如果用户可能想要省略较早的参数，使用可选位置参数。
*   AVOID 接受特殊"无参数"值的强制参数。
*   DO 使用包含开始和排除结束参数来接受范围。

##### 相等性

*   DO 如果您重写`==`，则重写`hashCode`。
*   DO 使您的`==`运算符遵循相等的数学规则。
*   AVOID 为可变类定义自定义相等性。
*   DON`T 使`==`的参数可空。

---

## Flutter 架构建议

本页面展示了架构最佳实践、它们为什么重要，以及我们是否为您的Flutter应用程序推荐它们。
您应该将这些建议视为建议，而不是坚定的规则，
您应该根据您应用程序的独特要求调整它们。

本页面上的最佳实践具有优先级，这反映了Flutter团队推荐它的强烈程度。

* **强烈推荐：** 如果您开始构建新应用程序，您应该始终实现这个建议。除非这样做会与您当前的方法根本冲突，否则您应该强烈考虑重构现有应用程序以实现此实践。
* **推荐：** 此实践可能会改善您的应用程序。
* **有条件的：** 此实践在特定情况下可以改善您的应用程序。

### 关注点分离

您应该将应用程序分为UI层和数据层。在这些层内，您应该按职责将逻辑进一步分离到类中。

#### 使用明确定义的数据和UI层。
**强烈推荐**

关注点分离是最重要的架构原则。
数据层向应用程序的其余部分暴露应用程序数据，并包含应用程序中的大部分业务逻辑。
UI层显示应用程序数据并监听用户事件。UI层包含UI逻辑和组件的独立类。

#### 在数据层中使用存储库模式。
**强烈推荐**

存储库模式是一种软件设计模式，它将数据访问逻辑与应用程序的其余部分隔离。
它在应用程序的业务逻辑和底层数据存储机制（数据库、API、文件系统等）之间创建了一个抽象层。
实际上，这意味着创建Repository类和Service类。

#### 在UI层中使用ViewModels和Views。(MVVM)
**强烈推荐**

关注点分离是最重要的架构原则。
这种特定的分离使您的代码更少出错，因为您的组件保持"愚蠢"。

#### 使用`ChangeNotifiers`和`Listenables`来处理组件更新。
**有条件的**

> 有许多选项来处理状态管理，最终决定取决于个人偏好。

`ChangeNotifier` API是Flutter SDK的一部分，是让您的组件观察ViewModel中变化的便捷方式。

#### 不要在组件中放入逻辑。
**强烈推荐**

逻辑应该封装在ViewModel的方法中。视图应该包含的唯一逻辑是：
* 基于ViewModel中的标志或可空字段显示和隐藏组件的简单if语句
* 依赖组件计算的动画逻辑
* 基于设备信息的布局逻辑，如屏幕大小或方向。
* 简单的路由逻辑

#### 使用域层。
**有条件的**

> 在具有复杂逻辑要求的应用程序中使用。

只有当您的应用程序具有超出复杂的逻辑，挤满了您的ViewModel，
或者您发现自己重复ViewModel中的逻辑时，才需要域层。
在非常大的应用程序中，用例是有用的，但在大多数应用程序中它们增加了不必要的开销。

### 处理数据

小心处理数据使您的代码更容易理解，更少出错，
并防止创建格式错误或意外的数据。

#### 使用单向数据流。
**强烈推荐**

数据更新应该只从数据层流向UI层。
UI层中的交互被发送到数据层进行处理。

#### 使用`Commands`来处理用户交互事件。
**推荐**

命令防止应用程序中的渲染错误，并标准化UI层向数据层发送事件的方式。

#### 使用不可变数据模型。
**强烈推荐**

不可变数据对于确保任何必要的更改只在适当的地方发生至关重要，通常在数据层或域层。
因为不可变对象在创建后不能修改，您必须创建一个新实例来反映更改。
这个过程防止UI层中的意外更新，并支持清晰的单向数据流。

#### 使用freezed或built_value生成不可变数据模型。
**推荐**

您可以使用包来帮助在数据模型中生成有用的功能，`freezed`或`built_value`。
这些可以生成常见的模型方法，如JSON序列化/反序列化、深度相等性检查和复制方法。
如果您有很多模型，这些代码生成包可能会给您的应用程序增加显著的构建时间。

#### 创建单独的API模型和域模型。
**有条件的**

> 在大型应用程序中使用。

使用单独的模型增加了冗长，但防止ViewModels和用例中的复杂性。

### 应用程序结构

组织良好的代码有利于应用程序本身的健康，以及从事代码的团队。

#### 使用依赖注入。
**强烈推荐**

依赖注入防止您的应用程序具有全局可访问的对象，这使您的代码更少出错。
我们建议您使用`provider`包来处理依赖注入。

#### 使用`go_router`进行导航。
**推荐**

Go_router是编写90% Flutter应用程序的首选方式。
有一些go_router不解决的特定用例，
在这种情况下，您可以直接使用`Flutter Navigator API`或尝试在`pub.dev`上找到的其他包。

#### 对类、文件和目录使用标准化命名约定。
**推荐**

我们建议为它们表示的架构组件命名类。
例如，您可能有以下类：

* HomeViewModel
* HomeScreen
* UserRepository
* ClientApiService

为了清晰，我们不建议使用可能与Flutter SDK对象混淆的名称。
例如，您应该将共享组件放在名为`ui/core/`的目录中，
而不是名为`/widgets`的目录。

#### 使用抽象存储库类
**强烈推荐**

存储库类是应用程序中所有数据的真实来源，
并促进与外部API的通信。
创建抽象存储库类允许您创建不同的实现，
这些实现可以用于不同的应用程序环境，如"开发"和"暂存"。

### 测试

良好的测试实践使您的应用程序灵活。
它还使添加新逻辑和新UI变得直接和低风险。

#### 分别和一起测试架构组件。
**强烈推荐**

* 为每个服务、存储库和ViewModel类编写单元测试。这些测试应该单独测试每个方法的逻辑。
* 为视图编写组件测试。测试路由和依赖注入特别重要。

#### 为测试制作假对象（并编写利用假对象的代码。）
**强烈推荐**

假对象不像关注任何给定方法的内部工作那样关注输入和输出。
如果您在编写应用程序代码时记住这一点，
您被迫编写模块化、轻量级的函数和类，具有明确定义的输入和输出。
---
description: '编写 Go 代码的指令，遵循地道 Go 实践和社区标准'
applyTo: '**/*.go,**/go.mod,**/go.sum'
---

# Go 开发指令

编写 Go 代码时遵循地道 Go 实践和社区标准。这些指令基于 [Effective Go](https://go.dev/doc/effective_go)、[Go Code Review Comments](https://go.dev/wiki/CodeReviewComments) 和 [Google's Go Style Guide](https://google.github.io/styleguide/go/)。

## 通用指令

- 编写简单、清晰和地道的 Go 代码
- 优先考虑清晰性和简单性而非巧妙性
- 遵循最小惊讶原则
- 保持主路径左对齐（最小化缩进）
- 尽早返回以减少嵌套
- 优先使用早期返回而非 if-else 链；使用 `if condition { return }` 模式避免 else 块
- 使零值有用
- 编写具有清晰、描述性名称的文档化代码
- 为导出的类型、函数、方法和包编写文档
- 使用 Go 模块进行依赖管理
- 利用 Go 标准库而不是重新发明轮子（例如，使用 `strings.Builder` 进行字符串连接，使用 `filepath.Join` 进行路径构造）
- 当功能存在时，优先选择标准库解决方案而非自定义实现
- 默认用英语编写注释；仅在用户要求时翻译
- 避免在代码和注释中使用表情符号

## 命名约定

### 包

- 使用小写、单词的包名
- 避免下划线、连字符或 mixedCaps
- 选择描述包提供什么的名称，而不是包含什么的名称
- 避免通用名称如 `util`、`common` 或 `base`
- 包名应该是单数，不是复数

#### 包声明规则（关键）：
- **绝不重复 `package` 声明** - 每个 Go 文件必须恰好有一个 `package` 行
- 编辑现有 `.go` 文件时：
  - **保留** 现有的 `package` 声明 - 不要添加另一个
  - 如果需要替换整个文件内容，从现有的包名开始
- 创建新 `.go` 文件时：
  - **在编写任何代码之前**，检查同一目录中的其他 `.go` 文件使用什么包名
  - 使用与该目录中现有文件相同的包名
  - 如果是新目录，使用目录名作为包名
  - 在文件最顶部编写**恰好一个** `package <name>` 行
- 使用文件创建或替换工具时：
  - **始终验证** 目标文件在添加前没有 `package` 声明
  - 如果替换文件内容，在新内容中只包含一个 `package` 声明
  - **绝不** 创建具有多个 `package` 行或重复声明的文件

### 变量和函数

- 使用 mixedCaps 或 MixedCaps（驼峰命名）而不是下划线
- 保持名称简短但具有描述性
- 仅对非常短的作用域使用单字母变量（如循环索引）
- 导出的名称以大写字母开头
- 未导出的名称以小写字母开头
- 避免结巴（例如，避免 `http.HTTPServer`，优先选择 `http.Server`）

### 接口

- 尽可能使用 -er 后缀命名接口（例如，`Reader`、`Writer`、`Formatter`）
- 单方法接口应该以方法命名（例如，`Read` → `Reader`）
- 保持接口小而专注

### 常量

- 导出常量使用 MixedCaps
- 未导出常量使用 mixedCaps
- 使用 `const` 块对相关常量进行分组
- 考虑使用类型常量以获得更好的类型安全性

## 代码样式和格式化

### 格式化

- 始终使用 `gofmt` 格式化代码
- 使用 `goimports` 自动管理导入
- 保持合理的行长度（没有硬性限制，但考虑可读性）
- 添加空行分隔代码的逻辑组

### 注释

- 努力编写文档化代码；优先选择清晰的变量名、函数名和代码结构而非注释
- 仅在必要时编写注释来解释复杂逻辑、业务规则或非显而易见的行为
- 默认用英语完整的句子编写注释
- 仅在特定用户要求时将注释翻译成其他语言
- 以所描述事物的名称开始句子
- 包注释应该以 "Package [name]" 开始
- 对大多数注释使用行注释（`//`）
- 谨慎使用块注释（`/* */`），主要用于包文档
- 记录为什么，而不是什么，除非什么很复杂
- 避免在注释和代码中使用表情符号

### 错误处理

- 在函数调用后立即检查错误
- 不要使用 `_` 忽略错误，除非有充分的理由（记录原因）
- 使用带有 `%w` 动词的 `fmt.Errorf` 包装带有上下文的错误
- 当需要检查特定错误时创建自定义错误类型
- 将错误返回作为最后的返回值
- 将错误变量命名为 `err`
- 保持错误消息小写且不以标点符号结尾

## 架构和项目结构

### 包组织

- 遵循标准 Go 项目布局约定
- 将 `main` 包放在 `cmd/` 目录中
- 将可重用包放在 `pkg/` 或 `internal/` 中
- 对不应被外部项目导入的包使用 `internal/`
- 将相关功能分组到包中
- 避免循环依赖

### 依赖管理

- 使用 Go 模块（`go.mod` 和 `go.sum`）
- 保持依赖最小化
- 定期更新依赖项以获取安全补丁
- 使用 `go mod tidy` 清理未使用的依赖
- 仅在必要时供应商化依赖

## 类型安全和语言特性

### 类型定义

- 定义类型以增加含义和类型安全性
- 使用结构标签进行 JSON、XML、数据库映射
- 优先选择显式类型转换
- 谨慎使用类型断言并检查第二个返回值
- 优先选择泛型而非无约束类型；当真正需要无约束类型时，使用预声明别名 `any` 而不是 `interface{}`（Go 1.18+）

### 指针 vs 值

- 对大结构体或需要修改接收者时使用指针接收者
- 对小结构体和期望不可变性时使用值接收者
- 当需要修改参数或对大结构体时使用指针参数
- 对小结构体和想要防止修改时使用值参数
- 在类型的方法集内保持一致
- 在选择指针 vs 值接收者时考虑零值

### 接口和组合

- 接受接口，返回具体类型
- 保持接口小（1-3 个方法是理想的）
- 使用嵌入进行组合
- 在接近使用的地方定义接口，而不是在实现的地方
- 除非必要，否则不要导出接口

## 并发

### Goroutines

- 在库中创建 goroutines 要谨慎；优先让调用者控制并发
- 如果必须在库中创建 goroutines，提供清晰的文档和清理机制
- 始终知道 goroutine 将如何退出
- 使用 `sync.WaitGroup` 或通道等待 goroutines
- 通过确保清理来避免 goroutine 泄漏

### 通道

- 使用通道在 goroutines 之间通信
- 不要通过共享内存通信；通过通信共享内存
- 从发送方关闭通道，而不是接收方
- 当知道容量时使用缓冲通道
- 使用 `select` 进行非阻塞操作

### 同步

- 使用 `sync.Mutex` 保护共享状态
- 保持关键部分小
- 当有很多读者时使用 `sync.RWMutex`
- 根据用例在通道和互斥锁之间选择：用于通信使用通道，用于保护状态使用互斥锁
- 使用 `sync.Once` 进行一次性初始化
- 按 Go 版本使用 WaitGroup：
	- 如果 `go.mod` 中 `go >= 1.25`，使用新的 `WaitGroup.Go` 方法（[文档](https://pkg.go.dev/sync#WaitGroup)）：
		```go
		var wg sync.WaitGroup
		wg.Go(task1)
		wg.Go(task2)
		wg.Wait()
		```
	- 如果 `go < 1.25`，使用经典的 `Add`/`Done` 模式

## 错误处理模式

### 创建错误

- 对简单静态错误使用 `errors.New`
- 对动态错误使用 `fmt.Errorf`
- 为领域特定错误创建自定义错误类型
- 为哨兵错误导出错误变量
- 使用 `errors.Is` 和 `errors.As` 进行错误检查

### 错误传播

- 在向上堆栈传播错误时添加上下文
- 不要记录和返回错误（选择一个）
- 在适当的级别处理错误
- 考虑使用结构化错误以获得更好的调试

## API 设计

### HTTP 处理程序

- 对简单处理程序使用 `http.HandlerFunc`
- 对需要状态的处理程序实现 `http.Handler`
- 对横切关注点使用中间件
- 设置适当的状态代码和标头
- 优雅地处理错误并返回适当的错误响应
- 按 Go 版本使用路由器：
	- 如果 `go >= 1.22`，优先选择增强的 `net/http` `ServeMux`，支持基于模式的路由和方法匹配
	- 如果 `go < 1.22`，使用经典的 `ServeMux` 并手动处理方法/路径（或在有理由时使用第三方路由器）

### JSON API

- 使用结构标签控制 JSON 编组
- 验证输入数据
- 对可选字段使用指针
- 考虑使用 `json.RawMessage` 进行延迟解析
- 适当处理 JSON 错误

### HTTP 客户端

- 保持客户端结构专注于配置和依赖项（例如，基础 URL、`*http.Client`、身份验证、默认标头）。它不能存储每个请求的状态
- 不要在客户端结构中存储或缓存 `*http.Request`，也不要在调用之间持久化请求特定的状态；相反，为每次方法调用构造新的请求
- 方法应该接受 `context.Context` 和输入参数，在本地组装 `*http.Request`（或通过每次调用创建的短期构建器/助手），然后调用 `c.httpClient.Do(req)`
- 如果重用请求构建逻辑，将其分解为未导出的辅助函数或每次调用的构建器类型；绝不在长期客户端中保持 `http.Request`（URL 参数、正文、标头）作为字段
- 确保底层 `*http.Client` 已配置（超时、传输）并且对于并发使用是安全的；避免在首次使用后修改 `Transport`
- 始终在发送的请求实例上设置标头，并关闭响应正文（`defer resp.Body.Close()`），适当处理错误

## 性能优化

### 内存管理

- 在热路径中最小化分配
- 尽可能重用对象（考虑 `sync.Pool`）
- 对小结构体使用值接收者
- 当大小已知时预分配切片
- 避免不必要的字符串转换

### I/O：读取器和缓冲区

- 大多数 `io.Reader` 流只能消费一次；读取会推进状态。不要假设读取器可以在没有特殊处理的情况下重读
- 如果必须多次读取数据，缓冲一次并按需重新创建读取器：
	- 使用 `io.ReadAll`（或有限读取）获取 `[]byte`，然后为每次重用通过 `bytes.NewReader(buf)` 或 `bytes.NewBuffer(buf)` 创建新的读取器
	- 对于字符串，使用 `strings.NewReader(s)`；您可以在 `*bytes.Reader` 上 `Seek(0, io.SeekStart)` 倒带
- 对于 HTTP 请求，不要重用已消费的 `req.Body`。相反：
	- 保持原始负载为 `[]byte` 并在每次发送前设置 `req.Body = io.NopCloser(bytes.NewReader(buf))`
	- 优先配置 `req.GetBody`，以便传输可以为重定向/重试重新创建正文：`req.GetBody = func() (io.ReadCloser, error) { return io.NopCloser(bytes.NewReader(buf)), nil }`
- 要在读取时复制流，使用 `io.TeeReader`（在传递时复制到缓冲区）或使用 `io.MultiWriter` 写入多个接收器
- 重用缓冲读取器：调用 `(*bufio.Reader).Reset(r)` 附加到新的底层读取器；不要期望它"倒带"，除非源支持查找
- 对于大负载，避免无界缓冲；考虑流式传输、`io.LimitReader` 或磁盘临时存储来控制内存

- 使用 `io.Pipe` 无需缓冲整个负载进行流式传输：
	- 在单独的 goroutine 中写入 `*io.PipeWriter`，同时读取器消费
	- 始终关闭写入器；失败时使用 `CloseWithError(err)`
	- `io.Pipe` 用于流式传输，不用于倒带或使读取器可重用

- **警告：**使用 `io.Pipe` 时（特别是与多部分写入器），所有写入必须严格按照顺序执行。不要并发或乱序写入 — 多部分边界和块顺序必须保留。乱序或并行写入可能损坏流并导致错误。

- 使用 `io.Pipe` 流式传输 multipart/form-data：
	- `pr, pw := io.Pipe()`; `mw := multipart.NewWriter(pw)`; 使用 `pr` 作为 HTTP 请求正文
	- 将 `Content-Type` 设置为 `mw.FormDataContentType()`
	- 在 goroutine 中：以正确顺序将所有部分写入 `mw`；出错时 `pw.CloseWithError(err)`；成功时 `mw.Close()` 然后 `pw.Close()`
	- 不要在长期客户端上存储请求/进行中表单状态；每次调用构建
	- 流式正文不可倒带；对于重试/重定向，缓冲小负载或提供 `GetBody`

### 分析

- 使用内置分析工具（`pprof`）
- 对关键代码路径进行基准测试
- 在优化之前进行分析
- 首先专注于算法改进
- 考虑使用 `testing.B` 进行基准测试

## 测试

### 测试组织

- 将测试保持在同一包中（白盒测试）
- 对黑盒测试使用 `_test` 包后缀
- 使用 `_test.go` 后缀命名测试文件
- 将测试文件放在它们测试的代码旁边

### 编写测试

- 对多个测试用例使用表驱动测试
- 使用 `Test_functionName_scenario` 描述性命名测试
- 使用带有 `t.Run` 的子测试以获得更好的组织
- 测试成功和错误情况
- 当它们增加价值时考虑使用 `testify` 或类似库，但不要过度简化简单测试

### 测试助手

- 使用 `t.Helper()` 标记辅助函数
- 为复杂设置创建测试夹具
- 对测试和基准测试中使用的函数使用 `testing.TB` 接口
- 使用 `t.Cleanup()` 清理资源

## 安全最佳实践

### 输入验证

- 验证所有外部输入
- 使用强类型防止无效状态
- 在 SQL 查询中使用之前清理数据
- 小心处理来自用户输入的文件路径
- 为不同上下文验证和转义数据（HTML、SQL、shell）

### 加密

- 使用标准库加密包
- 不要实现自己的加密
- 使用 crypto/rand 进行随机数生成
- 使用 bcrypt、scrypt 或 argon2 存储密码（考虑 golang.org/x/crypto 获取额外选项）
- 对网络通信使用 TLS

## 文档

### 代码文档

- 通过清晰的命名和结构优先编写文档化代码
- 为所有导出的符号编写清晰、简洁的解释文档
- 以符号名称开始文档
- 默认用英语编写文档
- 在有帮助时在文档中使用示例
- 保持文档接近代码
- 代码更改时更新文档
- 避免在文档和注释中使用表情符号

### README 和文档文件

- 包括清晰的设置说明
- 记录依赖项和要求
- 提供使用示例
- 记录配置选项
- 包括故障排除部分

## 工具和开发工作流

### 必要工具

- `go fmt`: 格式化代码
- `go vet`: 查找可疑构造
- `golangci-lint`: 附加检查（golint 已弃用）
- `go test`: 运行测试
- `go mod`: 管理依赖
- `go generate`: 代码生成

### 开发实践

- 提交前运行测试
- 使用预提交钩子进行格式化和检查
- 保持提交专注和原子性
- 编写有意义的提交消息
- 提交前审查差异

## 要避免的常见陷阱

- 不检查错误
- 忽略竞争条件
- 创建 goroutine 泄漏
- 不使用 defer 进行清理
- 并发修改映射
- 不理解 nil 接口 vs nil 指针
- 忘记关闭资源（文件、连接）
- 不必要地使用全局变量
- 过度使用无约束类型（例如，`any`）；优先选择特定类型或带约束的泛型类型参数。如果需要无约束类型，使用 `any` 而不是 `interface{}`
- 不考虑类型的零值
- **创建重复的 `package` 声明** - 这是编译错误；在添加包声明前始终检查现有文件
---
description: '针对 TypeScript 5.x 和 ES2022 输出的 TypeScript 开发指南'
applyTo: '**/*.ts'
---

# TypeScript 开发

> 这些指令假设项目使用 TypeScript 5.x（或更新版本）构建，编译到 ES2022 JavaScript 基线。如果您的运行时需要较旧的语言目标或向下级转换，请调整指导。

## 核心意图

- 尊重现有架构和编码标准。
- 优先选择可读、明确的解决方案而非巧妙的捷径。
- 在发明新抽象之前扩展现有抽象。
- 优先考虑可维护性和清晰性、简短的方法和类、干净的代码。

## 通用护栏

- 以 TypeScript 5.x / ES2022 为目标，优先选择原生特性而非 polyfill。
- 使用纯 ES 模块；绝不发出 `require`、`module.exports` 或 CommonJS 助手。
- 依赖项目的构建、检查和测试脚本，除非另有要求。
- 当意图不明显时，记录设计权衡。

## 项目组织

- 遵循存储库的文件夹和责任布局来组织新代码。
- 使用 kebab-case 文件名（例如，`user-session.ts`、`data-service.ts`），除非另有说明。
- 当有助于发现时，将测试、类型和助手放在其实现附近。
- 在添加新工具之前重用或扩展现有共享工具。

## 命名和样式

- 类、接口、枚举和类型别名使用 PascalCase；其他一切使用 camelCase。
- 跳过像 `I` 这样的接口前缀；依赖描述性名称。
- 根据行为或领域含义命名事物，而不是实现。

## 格式化和样式

- 提交前运行存储库的检查/格式化脚本（例如，`npm run lint`）。
- 匹配项目的缩进、引号样式和尾随逗号规则。
- 保持函数专注；当逻辑分支增长时提取助手。
- 在实用时优先选择不可变数据和纯函数。

## 类型系统期望

- 避免 `any`（隐式或显式）；优先选择 `unknown` 加上类型收缩。
- 对实时事件和状态机使用可区分联合。
- 集中化共享合约而不是重复形状。
- 使用 TypeScript 工具类型表达意图（例如，`Readonly`、`Partial`、`Record`）。

## 异步、事件和错误处理

- 使用 `async/await`；将 await 包装在带有结构化错误的 try/catch 中。
- 尽早保护边缘情况以避免深度嵌套。
- 通过项目的日志/遥测工具发送错误。
- 通过存储库的通知模式显示面向用户的错误。
- 对配置驱动的更新进行防抖处理并有确定性地处理资源。

## 架构和模式

- 遵循存储库的依赖注入或组合模式；保持模块单一目的。
- 在连接到生命周期时，观察现有的初始化和处理序列。
- 使用清晰接口保持传输层、领域层和表示层解耦。
- 添加服务时提供生命周期钩子（例如，`initialize`、`dispose`）和针对性测试。

## 外部集成

- 在热路径外实例化客户端并注入它们以实现可测试性。
- 绝不硬编码机密；从安全源加载它们。
- 对网络或 IO 调用应用重试、退避和取消。
- 规范化外部响应并将错误映射到领域形状。

## 安全实践

- 使用模式验证器或类型保护验证和清理外部输入。
- 避免动态代码执行和不受信任的模板渲染。
- 在渲染 HTML 之前对不受信任的内容进行编码；使用框架转义或可信类型。
- 使用参数化查询或准备语句阻止注入。
- 将机密保存在安全存储中，定期轮换它们，并请求最小权限范围。
- 对敏感数据优先选择不可变流和防御性副本。
- 仅使用经过验证的加密库。
- 及时修补依赖项并监控咨询。

## 配置和机密

- 通过共享助手访问配置并使用模式或专用验证器进行验证。
- 通过项目的安全存储处理机密；保护 `undefined` 和错误状态。
- 记录新配置键并更新相关测试。

## UI 和 UX 组件

- 在渲染前清理用户或外部内容。
- 保持 UI 层薄；将繁重逻辑推送到服务或状态管理器。
- 使用消息传递或事件将 UI 与业务逻辑解耦。

## 测试期望

- 使用项目的框架和命名样式添加或更新单元测试。
- 当行为跨越模块或平台 API 时，扩展集成或端到端测试套件。
- 提交前运行针对性测试脚本以获得快速反馈。
- 避免脆弱的时间断言；优先选择假计时器或注入的时钟。

## 性能和可靠性

- 延迟加载重型依赖项并在完成时处理它们。
- 将昂贵的工作推迟到用户需要时。
- 批处理或防抖高频事件以减少抖动。
- 跟踪资源生命周期以防止泄漏。

## 文档和注释

- 为公共 API 添加 JSDoc；在有帮助时包含 `@remarks` 或 `@example`。
- 编写捕获意图的注释，并在重构期间移除过时的注释。
- 在引入重要模式时更新架构或设计文档。